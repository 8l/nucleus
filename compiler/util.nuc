;;; TODO: Replace with a struct once they exist
(defun make-func (name arity args body llvm-func)
  (list name arity args body llvm-func))
(defun func-name (func) (first func))
(defun func-arity (func) (second func))
(defun func-args (func) (third func))
(defun func-body (func) (fourth func))
(defun func-llvm-func (func) (fifth func))

;;; TODO: Replace with a hash table once that exists
;;; TODO: These should go in the context, along with $module and $builder
(defvar $functions nil)

;;; TODO: Replace with a struct once they exist
(defun make-context (env) (list env))
(defun context-env (context) (first context))
(defun context-set-env (context new-env) (set-car context new-env))

(defun add-func (f)
  (cond
    ((not (nil? (get-func (func-name f))))
     (panic! (format nil "Duplicate definition of function '~'" (func-name f))))
    (true
      (set $functions (cons (cons (func-name f) f) $functions)))))

(defun get-func (name) (assoc-cdr name $functions))

(defvar $initialisers nil)

(defun add-initialiser (var init)
  (set $initialisers (cons (cons var init) $initialisers)))

(defun mangle-name (name)
  (format nil "nuc(~)" name))

(defun extend-env-with-values (context names values)
  (let ((env (context-env context)))
    (each (lambda (name-and-value)
            (let* ((name (car name-and-value))
                   (value (cdr name-and-value))
                   (var-on-stack (LLVMBuildAlloca $builder NUC-VAL
                                                  (string<-symbol name))))
              (LLVMBuildStore $builder value var-on-stack)
              (set env (cons (cons name var-on-stack) env))))
          (zip names values))
    (make-context env)))

(defun extend-env-with-pointers (context names ptrs)
  (make-context (append (zip names ptrs) (context-env context))))

(defun declare-function (name ret-type arg-types)
  (LLVMAddFunction
    $module
    (mangle-name name)
    (LLVMFunctionType ret-type arg-types (length arg-types) false)))

(defun get-value (context name)
  (let ((lvalue (get-lvalue context name)))
    (if (not (nil? lvalue))
      (LLVMBuildLoad $builder lvalue (string<-symbol name))
      (let ((const (get-constant name)))
        (if (not (nil? const))
          const
          (let ((func (get-func name)))
            (if (not (nil? func))
              (make-lambda (func-llvm-func func)
                           (LLVMCountParams (func-llvm-func func))
                           nil)
              nil)))))))

(defun get-lvalue (context name)
  (let ((global (LLVMGetNamedGlobal $module (mangle-name name))))
    (if (not (null? global))
      global
      (assoc-cdr name (context-env context)))))

(defun remove-lowtag (nuc-val)
  (LLVMBuildAnd
    $builder
    nuc-val
    ;; TODO: replace with (~ (1- (<< 1 LOWTAG-BITS)))
    (llvm-val<-int 18446744073709551608)
    "remove-lowtag"))

;; TODO: rename these 3
(defun llvm-val<-int (x)
  (LLVMConstInt NUC-VAL x false))

(defun llvm-val<-int8 (x)
  (LLVMConstInt (LLVMIntType 8) x false))

(defun llvm-val<-int32 (x)
  (LLVMConstInt (LLVMIntType 32) x false))

(defun cons<-nuc-val (nuc-val)
  ; TODO: type checking
  (LLVMBuildIntToPtr
    $builder
    (remove-lowtag nuc-val)
    CONS-CELL-PTR
    ""))

(defun compile-progn (context forms)
  (%compile-progn context (if (nil? forms) (list (quote nil)) forms)))

(defun %compile-progn (context forms)
  (let ((e (compile-expr context (car forms))))
    (if (nil? (cdr forms))
      e
      (%compile-progn context (cdr forms)))))

(defun compile-lambda (context name args body captured-vars)
  (let* ((params (repeat (length args) NUC-VAL))
         ;; We only take the lambda struct as our first argument if we have
         ;; any captured bindings. This allows us to easily deal with passing
         ;; around static functions in lambdas.
         ;; TODO: We could optimize further by not allocating a new closure if
         ;; we don't capture any bindings, and instead just creating a static
         ;; closure once at compile-time and returning it every time.
         (func (declare-function name NUC-VAL
                                 (if (nil? captured-vars)
                                   params
                                   (cons (LLVMPointerType CLOSURE 0) params)))))
    ;; TODO: set LLVM param names
    (LLVMPositionBuilderAtEnd $builder (LLVMAppendBasicBlock func "entry"))
    (let* ((params (llvm-params func))
           (new-context
             (extend-env-with-values
               (extend-env-with-pointers
                 context
                 captured-vars
                 (map (lambda (i-name)
                        (let ((i (car i-name))
                              (name (cdr i-name)))
                          (LLVMBuildLoad
                            $builder
                            (LLVMBuildGEP
                              $builder
                              (LLVMBuildGEP $builder (first params)
                                            (map llvm-val<-int32 (list 0 2))
                                            2
                                            "")
                              (map llvm-val<-int (list 0 i))
                              2
                              "get-var-from-closure")
                            "")))
                      (zip (range (length captured-vars)) captured-vars)))
               args
               (if (nil? captured-vars)
                 (llvm-params func)
                 (cdr (llvm-params func))))))
      (LLVMBuildRet $builder (compile-progn new-context body)))
    (when (LLVMVerifyFunction func LLVMPrintMessageAction)
      (LLVMDumpValue func)
      (panic! (format nil "ICE compiling lambda ~ (failed LLVMVerifyFunction). Function has been dumped" name)))
    func))

(defun call-closure (context nuc-val args)
  (let* ((closure (LLVMBuildIntToPtr
                    $builder (remove-lowtag nuc-val) (LLVMPointerType CLOSURE 0) ""))
         (func-pointer
           (LLVMBuildLoad
             $builder
             ;; TODO: BuildStructGEP?
             (LLVMBuildGEP
               $builder
               closure
               (map llvm-val<-int32 (list 0 0))
               2
               "")
             "load-func-pointer-from-struct"))
         (current-func (get-current-func $builder))
         (args (map (lambda (e) (compile-expr context e)) args))
         (args-len (length args))
         (captures
           (LLVMBuildGEP
             $builder
             (LLVMBuildGEP $builder closure (map llvm-val<-int32 (list 0 2)) 2 "")
             (map llvm-val<-int32 (list 0 0))
             2
             ""))
         (first-capture (LLVMBuildLoad $builder captures "")))
    ;; TODO: This is a case where a "declare in current scope" special form
    ;; could be really useful - a bunch of assignments interspersed with
    ;; side-effecting calls
    (let ((then-block (LLVMAppendBasicBlock current-func "doesn't-take-closure"))
          (else-block (LLVMAppendBasicBlock current-func "takes-closure"))
          (after-block (LLVMAppendBasicBlock current-func "after-call")))
      (LLVMBuildCondBr
        $builder
        (LLVMBuildICmp $builder LLVMIntEQ
                       (LLVMBuildPtrToInt $builder first-capture UINTPTR "")
                       (llvm-val<-int 0) "")
        then-block
        else-block)
      (LLVMPositionBuilderAtEnd $builder then-block)
      (let ((then-result (LLVMBuildCall
                           $builder
                           (LLVMBuildIntToPtr
                             $builder
                             func-pointer
                             (LLVMPointerType
                               (LLVMFunctionType
                                 NUC-VAL
                                 (repeat args-len NUC-VAL)
                                 args-len
                                 false)
                               0)
                             "cast-to-correct-function-type")
                           args
                           args-len
                           "call-closure")))
        (LLVMBuildBr $builder after-block)
        (LLVMPositionBuilderAtEnd $builder else-block)
        (let ((else-result
                (LLVMBuildCall
                  $builder
                  (LLVMBuildIntToPtr
                    $builder
                    func-pointer
                    (LLVMPointerType
                      (LLVMFunctionType
                        NUC-VAL
                        (cons (LLVMPointerType CLOSURE 0)
                              (repeat args-len NUC-VAL))
                        (1+ args-len)
                        false)
                      0)
                    "cast-to-correct-function-type")
                  (cons closure args)
                  (1+ args-len)
                  "call-closure")))
          (LLVMBuildBr $builder after-block)
          (LLVMPositionBuilderAtEnd $builder after-block)
          (llvm-phi $builder NUC-VAL (list (cons then-result then-block)
                                           (cons else-result else-block))))))))

(defun make-lambda (func arity captures)
  (let* ((ary-type (LLVMArrayType (LLVMPointerType NUC-VAL 0) (length captures)))
         (captures-array
           (if (nil? captures)
             (LLVMConstNull ary-type)
             (LLVMBuildAlloca $builder ary-type "make-captures-array"))))
    (enumerate (lambda (i capture)
                 ;; TODO: insert-value?
                 (LLVMBuildStore
                   $builder
                   (cdr capture)
                   (LLVMBuildGEP $builder captures-array
                                 (map llvm-val<-int (list 0 i))
                                 2 "array-elt")))
               captures)
    (LLVMBuildCall
      $builder
      (runtime-func "rt_make_lambda" NUC-VAL
                    (list UINTPTR (LLVMIntType 8) (LLVMIntType 32) UINTPTR))
      (list (LLVMBuildPtrToInt $builder func UINTPTR "func-pointer-to-int")
            (llvm-val<-int8 arity)
            (llvm-val<-int32 (length captures))
            (if (nil? captures)
              (llvm-val<-int 0)
              (LLVMBuildPtrToInt $builder captures-array UINTPTR "array-to-int")))
      4
      "make-lambda")))

(defun runtime-func (name return-type arg-types)
  (let ((func (LLVMGetNamedFunction $module name)))
    (if (not (null? func))
      func
      (LLVMAddFunction
        $module name
        (LLVMFunctionType return-type arg-types (length arg-types) false)))))

(defun global-string (str)
  (LLVMBuildGEP
    $builder
    (LLVMBuildGlobalString $builder str "")
    (list (llvm-val<-int 0) (llvm-val<-int 0))
    2
    "str-to-ptr"))
