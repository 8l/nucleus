(defvar $builtin-functions
  (list
    (cons '+ builtin+)
    (cons '- builtin-)
    (cons '* builtin*)
    (cons '% builtin%)
    (cons '/ builtin/)
    (cons 'cons builtin-cons)
    (cons 'car builtin-car)
    (cons 'cdr builtin-cdr)
    (cons 'eq? builtin-eq?)))
(defvar $special-forms
  (list
    (cons 'set special-form-set)
    (cons 'let special-form-let)
    (cons 'progn special-form-progn)
    (cons 'if special-form-if)
    (cons 'quote special-form-quote)
    (cons 'lambda special-form-lambda)

    ;; TODO: these should just be regular functions once we have varargs
    (cons 'format special-form-format)
    (cons 'list special-form-list)

    ;; TODO: these should be regular functions which call into some internal
    ;; compiler primitive once we have varargs
    (cons '< special-form-<)
    (cons '<= special-form-<=)
    (cons '> special-form->)
    (cons '>= special-form->=)

    ;; TODO: make these into macros
    (cons 'let* special-form-let*)
    (cons 'cond special-form-cond)
    (cons 'case special-form-case)
    (cons 'and special-form-and)
    (cons 'or special-form-or)
    (cons '%raw-call special-form-%raw-call)
    (cons '%c-call special-form-%c-call)
    (cons 'when special-form-when)
    (cons 'unless special-form-unless)))
;; TODO: Write these as more readable constant expressions
(defvar LLVM-NIL (llvm-val<-int 7))
(defvar LLVM-TRUE (llvm-val<-int 263))
(defvar LLVM-FALSE (llvm-val<-int 519))
(defvar LLVM-FIXNUM-T (llvm-val<-int 775))
(defvar LLVM-CONS-T (llvm-val<-int 1031))
(defvar LLVM-NIL-T (llvm-val<-int 1287))
(defvar LLVM-BOOL-T (llvm-val<-int 1543))
(defvar LLVM-FLOAT-T (llvm-val<-int 1799))
(defvar LLVM-SYMBOL-T (llvm-val<-int 2055))
(defvar LLVM-FOREIGN-T (llvm-val<-int 2311))
(defvar LLVM-STRING-T (llvm-val<-int 2567))
(defvar LLVM-LAMBDA-T (llvm-val<-int 2823))
(defvar $constants
  (list
    (cons 'nil LLVM-NIL)
    (cons 'true LLVM-TRUE)
    (cons 'false LLVM-FALSE)
    (cons 'fixnum-t LLVM-FIXNUM-T)
    (cons 'cons-t LLVM-CONS-T)
    (cons 'nil-t LLVM-NIL-T)
    (cons 'bool-t LLVM-BOOL-T)
    (cons 'float-t LLVM-FLOAT-T)
    (cons 'symbol-t LLVM-SYMBOL-T)
    (cons 'foreign-t LLVM-FOREIGN-T)
    (cons 'string-t LLVM-STRING-T)
    (cons 'lambda-t LLVM-LAMBDA-T)))

(defun get-special-form (name)
  (assoc-cdr name $special-forms))

(defun get-builtin-function (name)
  (assoc-cdr name $builtin-functions))

(defun get-constant (name)
  (assoc-cdr name $constants))

(defun special-form-set (context args)
  (let* ((env (context-env context))
         (name (first args))
         (lvalue (get-lvalue context name))
         (new-value (compile-expr context (second args))))
    (if (null? lvalue)
      (fail! context "Undefined variable")
      (LLVMBuildStore $builder new-value lvalue))
    new-value))

(defun special-form-let (context args)
  (let* ((bindings (first args))
         (body (rest args))
         (names (map first bindings))
         (values (map (lambda (e) (compile-expr context e))
                      (map second bindings)))
         (new-context (extend-env-with-values context names values)))
    (compile-progn new-context body)))

;; TODO: make into a macro
(defun special-form-let* (context args)
  (compile-expr context
                ;; TODO: Life without quasiquote is painful
                (if (nil? (first args))
                  (cons 'progn (rest args))
                  (list 'let (list (caar args))
                        (cons 'let* (cons (cdar args) (rest args)))))))

(defun special-form-progn (context args)
  (compile-progn context args))

(defun special-form-if (context args)
  ;; TODO: Enforce that 'condition' is a boolean at runtime
  (let* ((condition (compile-expr context (first args)))
         (then (second args))
         (else (if (length-is? args 2) 'nil (third args)))
         (current-func (get-current-func $builder))
         (then-block (LLVMAppendBasicBlock current-func "then"))
         (else-block (LLVMAppendBasicBlock current-func "else"))
         (after-block (LLVMAppendBasicBlock current-func "after")))
    (LLVMBuildCondBr
      $builder
      (LLVMBuildICmp $builder LLVMIntEQ condition LLVM-TRUE "")
      then-block
      else-block)
    (let* ((then-value (%build-branch context then then-block after-block))
           (then-resultant-block (LLVMGetInsertBlock $builder))
           (else-value (%build-branch context else else-block after-block))
           (else-resultant-block (LLVMGetInsertBlock $builder)))
      (LLVMPositionBuilderAtEnd $builder after-block)
      (llvm-phi $builder NUC-VAL (list (cons then-value then-resultant-block)
                                       (cons else-value else-resultant-block))))))

(defun %build-branch (context expr branch-block after-block)
  (LLVMPositionBuilderAtEnd $builder branch-block)
  (let ((compiled (compile-expr context expr)))
    (LLVMBuildBr $builder after-block)
    compiled))

(defun special-form-cond (context clauses)
  (compile-expr context
                (if (nil? clauses)
                  'nil
                  ;; TODO: Life without quasiquote is painful
                  (list 'if (caar clauses)
                        (cons 'progn (cdar clauses))
                        (cons 'cond (cdr clauses))))))

(defun special-form-case (context args)
  (let ((expr (first args))
        (clauses (rest args))
        (case-sym (gensym)))
    ;; TODO: Life without quasiquote is painful
    (compile-expr
      context
      (list 'let (list (list case-sym expr))
            (cons 'cond
                  (map (lambda (clause)
                         (cons (if (eq? (first clause) 'default)
                                 'true
                                 (list 'eq? case-sym (first clause)))
                               (rest clause)))
                       clauses))))))

(defun special-form-quote (context args)
  (let ((to-quote (first args)))
    (case (type to-quote)
      ;; TODO: merge all self-evaluating cases into once once 'case' supports
      ;; multiple values in the same clause
      (fixnum-t (compile-expr context to-quote))
      (nil-t LLVM-NIL)
      (cons-t (compile-expr context (list 'cons
                                          (list 'quote (car to-quote))
                                          (list 'quote (cdr to-quote)))))
      (symbol-t (LLVMBuildCall
                  $builder
                  (runtime-func "rt_intern_symbol" NUC-VAL
                                (list (LLVMPointerType (LLVMIntType 8) 0)))
                  (list (global-string (string<-symbol to-quote)))
                  1
                  "intern-const"))
      (default (fail! context (format nil "Don't know how to quote '~'" to-quote))))))

(defun special-form-and (context operands)
  (compile-expr context
                (if (nil? operands)
                  'true
                  (let ((operand-sym (gensym)))
                    ;; TODO: Life without quasiquote is painful
                    (list 'let
                          (list (list operand-sym (first operands)))
                          (list 'if operand-sym
                                (cons 'and (rest operands))
                                'false))))))

(defun special-form-or (context operands)
  (compile-expr context
                (if (nil? operands)
                  'false
                  (let ((operand-sym (gensym)))
                    ;; TODO: Life without quasiquote is painful
                    (list 'let
                          (list (list operand-sym (first operands)))
                          (list 'if operand-sym
                                'true
                                (cons 'or (rest operands))))))))

(defvar $lambda-counter 0)
(defun special-form-lambda (context args-and-body)
  (let* ((args (car args-and-body))
         (body (cdr args-and-body))
         (name (symbol<-string
                 (format nil "lambda_~" (set $lambda-counter
                                             (+ 1 $lambda-counter)))))
         (current-block (LLVMGetInsertBlock $builder))
         (captures (find-captured-vars context body args))
         (func (compile-lambda context name args body (map car captures))))
    ;; compile-lambda will change the builders position.
    (LLVMPositionBuilderAtEnd $builder current-block)
    (make-lambda func (length args) captures)))

(defun special-form-%raw-call (context name-and-args)
  (let ((name (first name-and-args))
        (args (rest name-and-args)))
    (LLVMBuildCall
      $builder
      ;; deliberately DON'T mangle
      (runtime-func (string<-symbol name) NUC-VAL (map (lambda (_) NUC-VAL) args))
      ;; TODO: compile-all
      (map (lambda (e) (compile-expr context e)) args)
      (length args)
      "%raw-call")))

(defun special-form-%c-call (context name-args-alist-return-type)
  (let ((name (first name-args-alist-return-type))
        (args-alist (second name-args-alist-return-type))
        (return-type (third name-args-alist-return-type)))
    (nuc-val<-c-val
      return-type
      (LLVMBuildCall
        $builder
        (runtime-func
          name
          (llvm-type<-type-spec context return-type)
          (map (lambda (entry) (llvm-type<-type-spec context (car entry))) args-alist))
        (map (lambda (entry) (c-val<-nuc-val
                               context
                               (car entry) (compile-expr context (cdr entry))))
             args-alist)
        (length args-alist)
        (if (eq? return-type 'void)
          ""
          "%c-call")))))

(defun special-form-format (context args)
  (compile-expr
    context
    ;; TODO: Life without quasiquote is painful
    (list '%format (first args) (second args)
          (cons 'list (cddr args)))))

(defun special-form-list (context args)
  (if (nil? args)
    LLVM-NIL
    (compile-expr
      context
      ;; TODO: Life without quasiquote is painful
      (list 'cons (first args) (cons 'list (rest args))))))

(defun special-form-unless (context args)
  (let ((condition (first args))
        (body (rest args)))
    (compile-expr
      context
      ;; TODO: Life without quasiquote is painful
      (list 'if condition 'nil (cons 'progn body)))))

(defun special-form-when (context args)
  (let ((condition (first args))
        (body (rest args)))
    (compile-expr
      context
      ;; TODO: Life without quasiquote is painful
      (list 'if condition (cons 'progn body)))))

(defun comparison (context cmp llvm-cmp operands)
  (if (length-is? operands 2)
    (LLVMBuildSelect
      $builder
      ;; Don't bother removing the lowtag, as it doesn't affect ordering
      (LLVMBuildICmp $builder llvm-cmp
                     (compile-expr context (first operands))
                     (compile-expr context (second operands))
                     "")
      LLVM-TRUE
      LLVM-FALSE
      "")
    ;; TODO: Life without quasiquote is painful
    (compile-expr context (list 'and
                                (list cmp
                                      (first operands)
                                      (second operands))
                                (cons cmp (cdr operands))))))
(defun special-form-< (context args) (comparison context '< LLVMIntSLT args))
(defun special-form-<= (context args) (comparison context '<= LLVMIntSLE args))
(defun special-form-> (context args) (comparison context '> LLVMIntSGT args))
(defun special-form->= (context args) (comparison context '>= LLVMIntSGE args))

;; We don't bother dealing with the lowtag here, because the lowtag for fixnums
;; is zero, and shifting is a multiplication, which distributes over addition
;; and subtraction - shifting each operand right and then the result left is
;; the same as not shifting at all.
(defun builtin+ (context args) (reduce (lambda (a b) (LLVMBuildAdd $builder a b "+")) args))
(defun builtin- (context args) (reduce (lambda (a b) (LLVMBuildSub $builder a b "-")) args))

(defun builtin* (context args)
  (reduce (lambda (a b)
            ;; Rather than shifting each operand right and the result left, we
            ;; just deal with the extra factor of 2^LOWTAG-BITS by shifting
            ;; the result.
            ;; TODO: If we have type information about the upper bound of the
            ;; operands we can batch these shifts rather than shifting every
            ;; time. The only reason we can't is overflow, which we may be able
            ;; to statically determine to be impossible.
            (LLVMBuildLShr
              $builder
              (LLVMBuildMul $builder a b "*")
              (llvm-val<-int LOWTAG-BITS)
              ""))
          args))
(defun builtin% (context args)
  (reduce (lambda (a b)
            ;; The same comments in builtin* apply here
            (LLVMBuildLShr
              $builder
              (LLVMBuildSRem $builder a b "*")
              (llvm-val<-int LOWTAG-BITS)
              ""))
          args))
(defun builtin/ (context args)
  (reduce (lambda (a b)
            ;; The same comments in builtin* apply here
            (LLVMBuildShl
              $builder
              (LLVMBuildSDiv $builder a b "*")
              (llvm-val<-int LOWTAG-BITS)
              ""))
          args))

(defun builtin-cons (context args)
  (LLVMBuildCall
    $builder (runtime-func "rt_cons" NUC-VAL (list NUC-VAL NUC-VAL)) args 2 "cons"))

(defun builtin-car (context args)
  (let ((cons-ptr (cons<-nuc-val (first args))))
    (LLVMBuildLoad $builder (LLVMBuildStructGEP $builder cons-ptr 0 "") "car")))

(defun builtin-cdr (context args)
  (let ((cons-ptr (cons<-nuc-val (first args))))
    (LLVMBuildLoad $builder (LLVMBuildStructGEP $builder cons-ptr 1 "") "cdr")))

(defun builtin-eq? (context args)
  (LLVMBuildSelect $builder
                   (LLVMBuildICmp $builder LLVMIntEQ (first args) (second args) "")
                   LLVM-TRUE
                   LLVM-FALSE
                   "eq?"))
