;;; TODO: Replace with a struct once they exist
(defun make-func (name arity arg-names arg-types return-type body llvm-func)
  (list name arity arg-names arg-types return-type body llvm-func))
(defun func-name (func) (first func))
(defun func-arity (func) (second func))
(defun func-arg-names (func) (third func))
(defun func-arg-types (func) (fourth func))
(defun func-return-type (func) (fifth func))
(defun func-body (func) (sixth func))
(defun func-llvm-func (func) (seventh func))

;;; TODO: Replace with a hash table once that exists
;;; TODO: These should go in the context, along with $module and $builder
(defvar $functions nil)

;;; TODO: Replace with a struct once they exist
(defun make-context (env file func) (list env file func))
(defun context-env (context) (first context))
(defun context-file (context) (second context))
(defun context-func (context) (third context))
(defun context-set-env (context new-env) (set-car context new-env))
(defun context-set-file (context new-file) (set-car (cdr context) new-file))
(defun context-set-func (context new-func) (set-car (cddr context) new-func))

;;; TODO: Replace with a struct once they exist
(defun make-binding (name llvm-ptr type-spec) (list name llvm-ptr type-spec))
(defun binding-name (binding) (first binding))
(defun binding-llvm-ptr (binding) (second binding))
(defun binding-type-spec (binding) (third binding))

;;; TODO: When an error occurs in a lambda, we should report the context better
;;; Maybe what we should do is store a chain of context switches terminating at
;;; toplevel form followed by filename, and we push/pop when we enter/leave a
;;; new context?
;;; e.g.: "Error: undefined variable 'foo' in lambda in lambda in function bar in file x.nuc
;;; (could merge adjacent identical contexts, like "lambda (2 levels deep)")
(defun fail! (context message)
  (let* ((func (context-func context))
         (str (if (nil? func)
                "toplevel form"
                (format nil "function ~" (func-name func)))))
    (panic! (format nil "Error compiling ~: ~" str message))))

(defun add-func (context f)
  (cond
    ((not (nil? (get-func (func-name f))))
     (fail! context (format nil "Duplicate definition of function '~'" (func-name f))))
    (true
      (set $functions (cons (cons (func-name f) f) $functions)))))

(defun add-global (context name type-spec)
  (let* ((global (LLVMAddGlobal $module NUC-VAL (mangle-name name))))
    (context-set-env context (cons (make-binding name global type-spec)
                                   (context-env context)))
    global))

(defun get-func (name) (assoc-cdr name $functions))

(defvar $initialisers nil)

(defun add-initialiser (var init)
  (set $initialisers (cons (cons var init) $initialisers)))

(defun mangle-name (name)
  (format nil "nuc(~)" name))

;; TODO: write this properly
(defun << (x y) (* x (expt 2 y)))

(defun extend-env-with-values (context names values)
  (let ((env (context-env context))
        (file (context-file context))
        (func (context-func context)))
    (each (lambda (name-and-value)
            (let* ((name (car name-and-value))
                   (value (cdr name-and-value))
                   (var-on-stack (LLVMBuildAlloca $builder NUC-VAL
                                                  (string<-symbol name))))
              (LLVMBuildStore $builder value var-on-stack)
              (set env (cons (make-binding name var-on-stack '?) env))))
          (zip names values))
    (make-context env file func)))

(defun extend-env-with-pointers (context names ptrs)
  (make-context (append (map2 (lambda (name ptr) (make-binding name ptr '?))
                              names ptrs)
                        (context-env context))
                (context-file context) (context-func context)))

(defun declare-function (name ret-type arg-types)
  (LLVMAddFunction
    $module
    name
    (LLVMFunctionType ret-type arg-types (length arg-types) false)))

;;; TODO: this should all be unified - we shouldn't look up globals and
;;; constants through a separate mechanism, it should all be in the env.
;;; That way we have proper binding objects for all types of variable.

(defun get-value (context name)
  (let ((lvalue (get-lvalue context name)))
    (if (not (nil? lvalue))
      (LLVMBuildLoad $builder lvalue (string<-symbol name))
      (let ((const (get-constant name)))
        (if (not (nil? const))
          const
          (let ((func (get-func name)))
            (if (not (nil? func))
              (make-lambda (func-llvm-func func)
                           (LLVMCountParams (func-llvm-func func))
                           nil)
              nil)))))))

(defun get-lvalue (context name)
  (let ((binding (find (lambda (binding) (eq? (binding-name binding) name))
                       (context-env context))))
    (if (nil? binding)
      nil
      (binding-llvm-ptr binding))))

(defun remove-lowtag (nuc-val)
  (LLVMBuildAnd $builder nuc-val
                ;; This is (~ (- (<< 1 LOWTAG-BITS) 1)).
                ;; We can't write that directly as it exceeds the 61-bit limit
                ;; of nucleus fixnums
                (LLVMConstIntOfString (LLVMIntType 64) "fffffffffffffff8" 16)
                "remove-lowtag"))

(defun add-lowtag (nuc-val tag)
  (LLVMBuildOr $builder
               (LLVMBuildPtrToInt $builder nuc-val NUC-VAL "ptr-to-int")
               (llvm-val<-int tag) "add-lowtag"))

;; TODO: rename these
(defun llvm-val<-int (x) (LLVMConstInt NUC-VAL x false))
(defun llvm-val<-int8 (x) (LLVMConstInt (LLVMIntType 8) x false))
(defun llvm-val<-int32 (x) (LLVMConstInt (LLVMIntType 32) x false))
(defun nuc-val<-int (int)
  (LLVMBuildShl $builder int (llvm-val<-int LOWTAG-BITS) "nuc-val<-int"))
(defun int<-nuc-val (nuc-val)
  ; TODO: type checking
  (LLVMBuildLShr $builder nuc-val (llvm-val<-int LOWTAG-BITS) "int<-nuc-val"))

(defun cons<-nuc-val (nuc-val)
  ; TODO: type checking
  (LLVMBuildIntToPtr $builder (remove-lowtag nuc-val) CONS-CELL-PTR ""))

(defun gc-alloc (size)
  (LLVMBuildCall
    $builder (runtime-func "gc_alloc" (LLVMPointerType NUC-VAL 0) (list SIZE-T))
    (list (llvm-val<-int size)) 1 "gc_alloc"))

(defun compile-progn (context forms)
  (%compile-progn context (if (nil? forms) (list 'nil) forms)))

(defun %compile-progn (context forms)
  (let ((e (compile-expr context (car forms))))
    (if (nil? (cdr forms))
      e
      (%compile-progn context (cdr forms)))))

;;; TODO: this feels kinda janky
(defun parse-arg-list (context arg-list)
  (let ((arg-names (map (lambda (arg)
                          (case (type arg)
                            (cons-t (first arg))
                            (symbol-t arg)
                            (default (fail! context (format nil "Invalid argument expression: ~" arg)))))
                        arg-list))
        (arg-types (map (lambda (arg)
                          (case (type arg)
                            (cons-t (second arg))
                            (symbol-t '?)
                            (default (fail! context (format nil "Invalid argument expression: ~" arg)))))
                        arg-list)))
    (cons arg-names arg-types)))

(defun compile-lambda (context name arg-list body captured-vars)
  (let* ((old-func (context-func context))
         (params (repeat (length arg-list) NUC-VAL))
         (names-and-types (parse-arg-list context arg-list))
         (arg-names (car names-and-types))
         (arg-types (cdr names-and-types))
         ;; We only take the lambda struct as our first argument if we have
         ;; any captured bindings. This allows us to easily deal with passing
         ;; around static functions in lambdas.
         ;; TODO: We could optimize further by not allocating a new closure if
         ;; we don't capture any bindings, and instead just creating a static
         ;; closure once at compile-time and returning it every time.
         (func (declare-function (mangle-name name) NUC-VAL
                                 (if (nil? captured-vars)
                                   params
                                   (cons (LLVMPointerType CLOSURE 0) params)))))
    ;; TODO: parse return type declarations
    (context-set-func context (make-func name (length arg-names) arg-names
                                         arg-types '? body func))
    ;; TODO: set LLVM param names
    (LLVMPositionBuilderAtEnd $builder (LLVMAppendBasicBlock func "entry"))
    (let* ((params (llvm-params func))
           (new-context
             (extend-env-with-values
               (extend-env-with-pointers
                 context
                 captured-vars
                 (map (lambda (i-name)
                        (let ((i (car i-name))
                              (name (cdr i-name)))
                          (LLVMBuildLoad
                            $builder
                            (LLVMBuildGEP
                              $builder
                              (LLVMBuildGEP $builder (first params)
                                            (map llvm-val<-int32 (list 0 2))
                                            2
                                            "")
                              (map llvm-val<-int (list 0 i))
                              2
                              "get-var-from-closure")
                            "")))
                      (zip (range (length captured-vars)) captured-vars)))
               arg-names
               (if (nil? captured-vars)
                 (llvm-params func)
                 (cdr (llvm-params func))))))
      (LLVMBuildRet $builder (compile-progn new-context body)))
    (when (LLVMVerifyFunction func LLVMPrintMessageAction)
      (LLVMDumpValue func)
      (fail! context (format nil "ICE compiling lambda ~ (failed LLVMVerifyFunction). Function has been dumped" name)))
    (context-set-func context old-func)
    func))

(defun call-closure (context nuc-val args)
  (let* ((closure (LLVMBuildIntToPtr
                    $builder (remove-lowtag nuc-val) (LLVMPointerType CLOSURE 0) ""))
         (func-pointer
           (LLVMBuildLoad
             $builder
             ;; TODO: BuildStructGEP?
             (LLVMBuildGEP
               $builder
               closure
               (map llvm-val<-int32 (list 0 0))
               2
               "")
             "load-func-pointer-from-struct"))
         (current-func (get-current-func $builder))
         (args (map (lambda (e) (compile-expr context e)) args))
         (args-len (length args))
         (captures
           (LLVMBuildGEP
             $builder
             (LLVMBuildGEP $builder closure (map llvm-val<-int32 (list 0 2)) 2 "")
             (map llvm-val<-int32 (list 0 0))
             2
             ""))
         (first-capture (LLVMBuildLoad $builder captures "")))
    ;; TODO: This is a case where a "declare in current scope" special form
    ;; could be really useful - a bunch of assignments interspersed with
    ;; side-effecting calls
    (let ((then-block (LLVMAppendBasicBlock current-func "doesn't-take-closure"))
          (else-block (LLVMAppendBasicBlock current-func "takes-closure"))
          (after-block (LLVMAppendBasicBlock current-func "after-call")))
      (LLVMBuildCondBr
        $builder
        (LLVMBuildICmp $builder LLVMIntEQ
                       (LLVMBuildPtrToInt $builder first-capture UINTPTR "")
                       (llvm-val<-int 0) "")
        then-block
        else-block)
      (LLVMPositionBuilderAtEnd $builder then-block)
      (let ((then-result (LLVMBuildCall
                           $builder
                           (LLVMBuildIntToPtr
                             $builder
                             func-pointer
                             (LLVMPointerType
                               (LLVMFunctionType
                                 NUC-VAL
                                 (repeat args-len NUC-VAL)
                                 args-len
                                 false)
                               0)
                             "cast-to-correct-function-type")
                           args
                           args-len
                           "call-closure")))
        (LLVMBuildBr $builder after-block)
        (LLVMPositionBuilderAtEnd $builder else-block)
        (let ((else-result
                (LLVMBuildCall
                  $builder
                  (LLVMBuildIntToPtr
                    $builder
                    func-pointer
                    (LLVMPointerType
                      (LLVMFunctionType
                        NUC-VAL
                        (cons (LLVMPointerType CLOSURE 0)
                              (repeat args-len NUC-VAL))
                        (+ 1 args-len)
                        false)
                      0)
                    "cast-to-correct-function-type")
                  (cons closure args)
                  (+ 1 args-len)
                  "call-closure")))
          (LLVMBuildBr $builder after-block)
          (LLVMPositionBuilderAtEnd $builder after-block)
          (llvm-phi $builder NUC-VAL (list (cons then-result then-block)
                                           (cons else-result else-block))))))))

(defun make-lambda (func arity captures)
  (let* ((ary-type (LLVMArrayType (LLVMPointerType NUC-VAL 0) (length captures)))
         (captures-array
           (if (nil? captures)
             (LLVMConstNull ary-type)
             (LLVMBuildAlloca $builder ary-type "make-captures-array"))))
    (enumerate (lambda (i capture)
                 ;; TODO: insert-value?
                 (LLVMBuildStore
                   $builder
                   (cdr capture)
                   (LLVMBuildGEP $builder captures-array
                                 (map llvm-val<-int (list 0 i))
                                 2 "array-elt")))
               captures)
    (LLVMBuildCall
      $builder
      (runtime-func "rt_make_lambda" NUC-VAL
                    (list UINTPTR (LLVMIntType 8) (LLVMIntType 32) UINTPTR))
      (list (LLVMBuildPtrToInt $builder func UINTPTR "func-pointer-to-int")
            (llvm-val<-int8 arity)
            (llvm-val<-int32 (length captures))
            (if (nil? captures)
              (llvm-val<-int 0)
              (LLVMBuildPtrToInt $builder captures-array UINTPTR "array-to-int")))
      4
      "make-lambda")))

(defun runtime-func (name return-type arg-types)
  (let ((func (LLVMGetNamedFunction $module name)))
    (if (not (null? func))
      func
      (LLVMAddFunction
        $module name
        (LLVMFunctionType return-type arg-types (length arg-types) false)))))

(defun global-string (str)
  (LLVMBuildGEP
    $builder
    (LLVMBuildGlobalString $builder str "")
    (list (llvm-val<-int 0) (llvm-val<-int 0))
    2
    "str-to-ptr"))

(defun find-captured-vars (context body args)
  (unique (%find-captured-vars context body args)))

(defun %find-captured-vars (context sexpr to-ignore)
  (cond
    ((atom? sexpr)
     (if (member? sexpr to-ignore)
       nil
       (let ((binding (get-lvalue context sexpr)))
         (if (nil? binding) nil (list (cons sexpr binding))))))
    ((eq? (car sexpr) 'let)
     ;; let/let* can shadow variables, producing spurious captures
     (let ((to-ignore (append! (map car (second sexpr)) to-ignore)))
       (append!
         (mappend (lambda (clause)
                    (%find-captured-vars context (second clause) to-ignore))
                  (second sexpr))
         (%find-captured-vars context (cddr sexpr) to-ignore))))
    (true (mappend (lambda (e) (%find-captured-vars context e to-ignore)) sexpr))))

(defun llvm-type<-type-spec (context type-spec)
  (case type-spec
    ('* UINTPTR)
    ('string (LLVMPointerType (LLVMIntType 8) 0))
    ('void (LLVMVoidType))
    ('int INT) ('uint INT) ('bool INT)
    ('uint8 (LLVMIntType 8))
    ('long LONG)
    ('long-long LONG-LONG)
    ('array (LLVMPointerType UINTPTR 0))
    (default (fail! context (format nil "Unsupported type-spec '~'" type-spec)))))

(defun c-val<-nuc-val (context type-spec val)
  (cond
    ((eq? type-spec '*)
     (LLVMBuildIntToPtr
       $builder
       (LLVMBuildLoad
         $builder
         (LLVMBuildIntToPtr
           $builder (remove-lowtag val) (LLVMPointerType NUC-VAL 0) "")
         "")
       UINTPTR
       ""))
    ((eq? type-spec 'string)
     (LLVMBuildCall
       $builder
       (runtime-func "rt_nuc_str_to_c_str" (LLVMPointerType (LLVMIntType 8) 0) (list NUC-VAL))
       (list val) 1 "c-val<-nuc-val"))
    ((member? type-spec (list 'int 'uint 'long 'long-long 'uint8))
     (LLVMBuildIntCast
       $builder
       (int<-nuc-val val)
       (llvm-type<-type-spec context type-spec)
       "cast-nuc-val"))
    ((eq? type-spec 'bool)
      (LLVMBuildIntCast
        $builder
        (LLVMBuildICmp $builder LLVMIntEQ val LLVM-TRUE "int<-bool")
        (llvm-type<-type-spec context 'int)
        ""))
    ((eq? type-spec 'array)
     (LLVMBuildCall
       $builder
       (runtime-func "rt_list_to_array" (llvm-type<-type-spec context type-spec) (list NUC-VAL))
       (list val)
       1
       "array<-list"))
    (true (fail! context (format nil "Unsupported type-spec '~'" type-spec)))))

(defun nuc-val<-c-val (type-spec val)
  (cond
    ((eq? type-spec '*)
      (add-lowtag
        (let ((box (gc-alloc PTR-BYTES)))
          (LLVMBuildStore $builder (LLVMBuildPtrToInt $builder val NUC-VAL "") box)
          box)
        6))
    ((eq? type-spec 'void) LLVM-NIL)
    ((member? type-spec (list 'int 'uint 'long 'long-long 'uint8))
     (nuc-val<-int
       (LLVMBuildIntCast $builder val NUC-VAL "cast-int-to-nuc-val")))
    ((eq? type-spec 'bool)
     (LLVMBuildSelect $builder
                      (LLVMBuildICmp $builder LLVMIntEQ val (llvm-val<-int32 0) "")
                      LLVM-FALSE LLVM-TRUE ""))))
