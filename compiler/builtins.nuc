(defvar $builtin-functions
  (list
    (cons (quote +) builtin+)
    (cons (quote -) builtin-)
    (cons (quote *) builtin*)
    (cons (quote /) builtin/)
    (cons (quote cons) builtin-cons)
    (cons (quote car) builtin-car)
    (cons (quote cdr) builtin-cdr)
    (cons (quote eq?) builtin-eq?)))
(defvar $special-forms
  (list
    (cons (quote set) special-form-set)
    (cons (quote let) special-form-let)
    (cons (quote progn) special-form-progn)
    (cons (quote if) special-form-if)

    ;; TODO: make these into macros
    (cons (quote let*) special-form-let*)
    (cons (quote cond) special-form-cond)))
;; TODO: Write these as a more readable constant expression
(defvar LLVM-NIL (llvm-val<-int 7))
(defvar LLVM-TRUE (llvm-val<-int 263))
(defvar LLVM-FALSE (llvm-val<-int 519))
(defvar $constants
  (list
    (cons (quote nil) LLVM-NIL)
    (cons (quote true) LLVM-TRUE)
    (cons (quote false) LLVM-FALSE)))

(defun get-special-form (name)
  (assoc-cdr name $special-forms))

(defun get-builtin-function (name)
  (assoc-cdr name $builtin-functions))

(defun get-constant (name)
  (assoc-cdr name $constants))

(defun special-form-set (context args)
  (let* ((env (context-env context))
         (name (first args))
         (lvalue (get-lvalue context name))
         (new-value (compile-expr context (second args))))
    (if (null? lvalue)
      (panic! "Undefined variable")
      (LLVMBuildStore $builder new-value lvalue ""))
    new-value))

(defun special-form-progn (context args)
  (compile-progn context args))

(defun special-form-let (context args)
  (let* ((bindings (first args))
         (body (rest args))
         (names (map first bindings))
         (values (map (lambda (e) (compile-expr context e))
                      (map second bindings)))
         (new-context (extend-env context names values)))
    (compile-progn new-context body)))

;; TODO: make into a macro
(defun special-form-let* (context args)
  (compile-expr context
                ;; TODO: Life without quasiquote is painful
                (if (nil? (first args))
                  (cons (quote progn) (rest args))
                  (list (quote let) (list (caar args))
                        (cons (quote let*) (cons (cdar args) (rest args)))))))

(defun special-form-progn (context args)
  (compile-progn context args))

(defun special-form-if (context args)
  ;; TODO: Enforce that 'condition' is a boolean at runtime
  (let* ((condition (compile-expr context (first args)))
         (then (second args))
         (else (third args))
         (current-func (func-llvm-func (context-current-func context)))
         (then-block (LLVMAppendBasicBlock current-func "then"))
         (else-block (LLVMAppendBasicBlock current-func "else"))
         (after-block (LLVMAppendBasicBlock current-func "after")))
    (LLVMBuildCondBr
      $builder
      (LLVMBuildICmp $builder LLVMIntEQ condition LLVM-TRUE "")
      then-block
      else-block)
    (let* ((then-value (%build-branch context then then-block after-block))
           (then-resultant-block (LLVMGetInsertBlock $builder))
           (else-value (%build-branch context else else-block after-block))
           (else-resultant-block (LLVMGetInsertBlock $builder)))
      (LLVMPositionBuilderAtEnd $builder after-block)
      (llvm-phi $builder NUC-VAL (list (cons then-value then-resultant-block)
                                       (cons else-value else-resultant-block))))))

(defun %build-branch (context expr branch-block after-block)
  (LLVMPositionBuilderAtEnd $builder branch-block)
  (let ((compiled (compile-expr context expr)))
    (LLVMBuildBr $builder after-block)
    compiled))

(defun special-form-cond (context clauses)
  (compile-expr context
                (if (nil? clauses)
                  (quote nil)
                  ;; TODO: Life without quasiquote is painful
                  (list (quote if) (caar clauses)
                        (cons (quote progn) (cdar clauses))
                        (cons (quote cond) (cdr clauses))))))

;; We don't bother dealing with the lowtag here, because the lowtag for fixnums
;; is zero, and shifting is a multiplication, which distributes over addition
;; and subtraction - shifting each operand right and then the result left is
;; the same as not shifting at all.
(defun builtin+ (args) (reduce (lambda (a b) (LLVMBuildAdd $builder a b "+")) args))
(defun builtin- (args) (reduce (lambda (a b) (LLVMBuildSub $builder a b "-")) args))
(defun builtin* (args)
  (reduce (lambda (a b)
            ;; Rather than shifting each operand right and the result left, we
            ;; just deal with the extra factor of 2^LOWTAG-BITS by shifting
            ;; the result.
            ;; TODO: If we have type information about the upper bound of the
            ;; operands we can batch these shifts rather than shifting every
            ;; time. The only reason we can't is overflow, which we may be able
            ;; to statically determine to be impossible.
            (LLVMBuildLShr
              $builder
              (LLVMBuildMul $builder a b "*")
              (llvm-val<-int LOWTAG-BITS)
              ""))
          args))
(defun builtin/ (args)
  (reduce (lambda (a b)
            ;; The same comments in builtin* apply here
            (LLVMBuildShl
              $builder
              (LLVMBuildSDiv $builder a b "*")
              (llvm-val<-int LOWTAG-BITS)
              ""))
          args))

(defun builtin-cons (args)
  (LLVMBuildCall $builder
                 (runtime-func "rt_cons" NUC-VAL (list NUC-VAL NUC-VAL))
                 args
                 2
                 "cons"))

(defun builtin-car (args)
  (let ((cons-ptr (cons<-nuc-val (first args))))
    (LLVMBuildLoad $builder (LLVMBuildStructGEP $builder cons-ptr 0 "") "car")))

(defun builtin-cdr (args)
  (let ((cons-ptr (cons<-nuc-val (first args))))
    (LLVMBuildLoad $builder (LLVMBuildStructGEP $builder cons-ptr 1 "") "cdr")))

(defun builtin-eq? (args)
  (LLVMBuildSelect $builder
                   (LLVMBuildICmp $builder LLVMIntEQ (first args) (second args) "")
                   LLVM-TRUE
                   LLVM-FALSE
                   "eq?"))
