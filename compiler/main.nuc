;;; TODO: including a directory should look for 'lib' inside it
(include "llvm/lib")

;;; TODO: currently we have to put "types" before "builtins", as there are some
;;; static initializers in "builtins" that depend on variables in "types", and
;;; we don't currently figure out dependencies and order the initializers
;;; appropriately. This shouldn't be necessary later.
(include "types")
(include "builtins")
(include "util")

(defvar $module)
(defvar $builder)

(defun main ()
  (cond
    ((not (length-is? $argv 1))
     (set $builder (LLVMCreateBuilder))
     (let* ((nucc-dir (dirname (ensure-absolute (first $argv) (current-dir))))
            (stdlib (join-path nucc-dir "stdlib/lib.nuc"))
            (non-flag-args nil)
            (output-llvm-ir false)
            (output-asm false))
       (each (lambda (arg)
               (cond
                 ((string-eq? arg "-ir")
                  (set output-llvm-ir true))
                 ((string-eq? arg "-asm")
                  (set output-asm true))
                 (true
                   (set non-flag-args (cons arg non-flag-args)))))
             (rest $argv))
       (when (and output-llvm-ir output-asm)
         (panic! "Cannot specify both of '-ir' and '-asm'"))
       (set non-flag-args (reverse non-flag-args))
       (let* ((input-filename (ensure-absolute (first non-flag-args) (current-dir)))
              (output-filename (if (length-is? non-flag-args 1)
                                 "a.out"
                                 (second non-flag-args)))
              (llvm-context (LLVMGetGlobalContext))
              (context (make-context nil nil)))
         (set $module (LLVMModuleCreateWithNameInContext
                        input-filename llvm-context))
         (process-toplevel-form context (quote (defvar $status-code 0)))
         ;; TODO: we should have a flag to not include the standard library, and
         ;; then enable it on all tests that don't need standard library functions.
         ;; That way, if the standard library is broken, only the tests that
         ;; actually use it break.
         (process-file context stdlib)
         (process-file context input-filename)
         (each (lambda (f) (compile-function context (cdr f))) $functions)
         (let ((entry-point (LLVMGetNamedFunction
                              $module (mangle-name (quote main))))
               (main-func (LLVMAddFunction $module "main"
                                           (LLVMFunctionType INT nil 0 false))))
           (when (null? entry-point)
             (panic! "No main function defined."))
           (LLVMPositionBuilderAtEnd $builder
                                     (LLVMAppendBasicBlock main-func "entry"))
           (each (lambda (init)
                   (let ((var (car init))
                         (expr (cdr init)))
                     (LLVMBuildStore $builder (compile-expr context expr) var)))
                 (reverse $initialisers))
           (LLVMBuildCall $builder entry-point nil 0 "")
           (LLVMBuildRet
             $builder
             (LLVMBuildIntCast
               $builder
               (LLVMBuildLShr
                 $builder
                 (LLVMBuildLoad
                   $builder (get-lvalue context (quote $status-code)) "")
                 (llvm-val<-int LOWTAG-BITS)
                 "")
               INT
               "truncate-status-code")))
         (when (LLVMVerifyModule $module LLVMPrintMessageAction NULL)
           (LLVMDumpModule $module)
           (panic! "ICE: Module failed LLVMVerifyModule. Module has been dumped"))
         ;; TODO: not portable
         (let ((tmp-bc-file (format nil "/tmp/~.bc" (random)))
               (tmp-o-file (format nil "/tmp/~.o" (random))))
           (LLVMWriteBitcodeToFile $module tmp-bc-file)
           (cond
             (output-llvm-ir
               (let ((llvm-dis-success
                       (zero? (exec "llvm-dis"
                                    (list tmp-bc-file "-o" output-filename)))))
                 (exec "rm" (list tmp-bc-file))
                 (unless llvm-dis-success
                   (panic! "llvm-dis failed"))))
             (output-asm
               (let ((llc-success (zero? (exec "llc"
                                               (list tmp-bc-file "-filetype=asm"
                                                     "-o" output-filename)))))
                 (exec "rm" (list tmp-bc-file))
                 (unless llc-success
                   (panic! "llc failed"))))
             (true
               ;; TODO: A more intelligent way of finding the runtime
               (unless (zero? (exec "llvm-link" (list tmp-bc-file
                                                      "runtime/nuc-runtime.bc"
                                                      "-o" tmp-bc-file)))
                 (exec "rm" (list tmp-bc-file))
                 (panic! "llvm-link failed"))
               (unless (zero? (exec "llc" (list tmp-bc-file "-filetype=obj"
                                                "-o" tmp-o-file)))
                 (exec "rm" (list tmp-bc-file))
                 (panic! "llc failed"))
               (unless (zero? (exec "gcc" (list "-lm"
                                                tmp-o-file
                                                "-o" output-filename)))
                 (exec "rm" (list tmp-bc-file tmp-o-file))
                 (panic! "gcc failed"))
               (exec "rm" (list tmp-bc-file tmp-o-file))))))))
    (true
      (write-string-ln "Usage: nucc <input filename>"))))

(defun process-toplevel-form (context form)
  (case (first form)
    ((quote defun)
     (unless (length>= form 3)
       (panic! (format nil "Malformed 'defun' form: ~" form)))
     (let ((name (second form))
           (args (third form))
           (body (cdddr form)))
       (unless (and (symbol? name) (list? args))
         (panic! (format nil "Malformed 'defun' form: ~" form)))
       (let ((llvm-func (declare-function
                          (mangle-name (second form)) NUC-VAL
                          (map (lambda (_) NUC-VAL) (third form)))))
         (add-func (make-func name (length args) args body llvm-func)))))
    ((quote defvar)
     (let* ((name (second form))
            (value (if (length-is? form 3) (third form) (quote nil)))
            (init (llvm-val<-int (if (int? value)
                                   (<< value LOWTAG-BITS)
                                   0)))
            (var (LLVMAddGlobal $module NUC-VAL (mangle-name name))))
       (LLVMSetInitializer var init)
       (unless (int? value)
         (add-initialiser var value))))
    ((quote extern)
      (unless (length-is? (cdr form) 4)
        (panic! (format
                  nil
                  "Invalid number of arguments to 'extern' (got ~, expected 4)"
                  (length (cdr form)))))
      ;; TODO: possibly better to do this directly?
      (process-toplevel-form
        context
        (let ((args (map (lambda (_) (gensym)) (repeat (third form) nil))))
          ;; TODO: Life without quasiquote is painful
          (list (quote defun) (fifth form) args
                ;; TODO: we should make the name be a symbol - change this once
                ;; we're bootstrapped
                (cons (quote %raw-call) (cons (second form) args))))))
    ((quote cfun)
     (unless (length-is? (cdr form) 4)
       (panic! (format
                 nil
                 "Invalid number of arguments to 'cfun' (got ~, expected 4)"
                 (length (cdr form)))))
     (let* ((name (second form))
            (arg-types (third form))
            (ret-type (fifth form))
            (args (map (lambda (_) (gensym)) arg-types )))
       (process-toplevel-form
         context
         ;; TODO: Life without quasiquote is painful
         (list (quote defun) name args
               (list (quote %c-call) (string<-symbol name) (zip arg-types args) ret-type)))))
    ((quote include)
     (unless (length-is? (cdr form) 1)
       (panic! (format
                 nil
                 "Invalid number of arguments to 'include' (got ~, expected 1)"
                 (length (cdr form)))))
     (let* ((including-file (context-file context))
            (filename (if (string-ends-with? (second form) ".nuc")
                        (second form)
                        (string-concat (second form) ".nuc")))
            (included-file (ensure-absolute filename
                                            (dirname including-file))))
       (process-file context included-file)))
    (default
      (panic! (format nil "Invalid top-level form '~'" (first form))))))

(defun process-file (context filename)
  (unless (file-exists? filename)
    (panic! (format nil "Could not find file ~" filename)))
  (let ((old-file (context-file context)))
    (context-set-file context filename)
    (let* ((file (open filename))
           (forms (read-all file)))
      (close file)
      (each (lambda (form) (process-toplevel-form context form)) forms))
    (context-set-file context old-file)))

(defun compile-function (context func)
  (let* ((args (func-args func))
         (env (context-env context))
         (llvm-func (func-llvm-func func))
         (params (llvm-params llvm-func)))
    (assert! (not (null? llvm-func)) "Function should have been declared")
    (LLVMPositionBuilderAtEnd $builder (LLVMAppendBasicBlock llvm-func "entry"))
    ;; TODO: set LLVM param names
    (set context (extend-env-with-values context args params))
    (let ((compiled (LLVMBuildRet $builder
                                  (compile-progn context (func-body func)))))
      (when (LLVMVerifyFunction llvm-func LLVMPrintMessageAction)
        (LLVMDumpValue llvm-func)
        (panic! "ICE: Function failed LLVMVerifyFunction. Function has been dumped"))
      compiled)))

(defun compile-expr (context expr)
  (case (type expr)
    ;; TODO: limit on size
    (fixnum-t (llvm-val<-int (<< expr LOWTAG-BITS)))
    (symbol-t
      (let ((value (get-value context expr)))
        (if (nil? value)
          (panic! (format nil "Undefined variable '~'" expr))
          value)))
    (cons-t (compile-form context expr))
    (string-t (LLVMBuildCall
                $builder
                (runtime-func "rt_make_string"
                              NUC-VAL
                              (list SIZE-T (LLVMPointerType (LLVMIntType 8) 0)))
                (list (llvm-val<-int (length expr)) (global-string expr))
                2
                "make-string-literal"))
    (default (panic!
               (format nil
                       "Don't know how to compile this type of expression: ~"
                       expr)))))

(defun compile-form (context form)
  (let* ((name (car form))
         (args (cdr form))
         (special-form (get-special-form name)))
    (if (not (nil? special-form))
      (special-form context args)
      (let ((builtin-function (get-builtin-function name)))
        (if (not (nil? builtin-function))
          (builtin-function context (map (lambda (arg)
                                           (compile-expr context arg))
                                         args))
          (let ((func (get-func name)))
            (if (not (nil? func))
              ;; Calling a static function
              (let ((llvm-func (func-llvm-func func)))
                (if (eq? (LLVMCountParams llvm-func) (length args))
                  (LLVMBuildCall $builder llvm-func
                                 (map (lambda (e) (compile-expr context e)) args)
                                 (length args) "")
                  (panic!  (format nil "Invalid number of arguments to function '~' (got ~, expected ~)"
                                   name (length args) (LLVMCountParams llvm-func)))))
              (let ((value (compile-expr context name)))
                (if (not (nil? value))
                  ;; Calling a closure pointer
                  (call-closure context value args)
                  (panic! (format nil "Undefined function '~'" name)))))))))))
