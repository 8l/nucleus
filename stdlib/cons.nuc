;;;; Everything to do with conses

(extern rt_cons 2 -> cons)
(extern rt_set_car 2 -> set-car)
(extern rt_set_cdr 2 -> set-cdr)
(extern rt_char_list_to_string 1 -> string<-char-list)
(extern rt_string_to_char_list 1 -> char-list<-string)

(defun caar (c) (car (car c)))
(defun cadr (c) (car (cdr c)))
(defun cdar (c) (cdr (car c)))
(defun cddr (c) (cdr (cdr c)))
(defun caaar (c) (car (car (car c))))
(defun caadr (c) (car (car (cdr c))))
(defun cadar (c) (car (cdr (car c))))
(defun caddr (c) (car (cdr (cdr c))))
(defun cdaar (c) (cdr (car (car c))))
(defun cdadr (c) (cdr (car (cdr c))))
(defun cddar (c) (cdr (cdr (car c))))
(defun cdddr (c) (cdr (cdr (cdr c))))
(defun caaaar (c) (car (car (car (car c)))))
(defun caaadr (c) (car (car (car (cdr c)))))
(defun caadar (c) (car (car (cdr (car c)))))
(defun caaddr (c) (car (car (cdr (cdr c)))))
(defun cadaar (c) (car (cdr (car (car c)))))
(defun cadadr (c) (car (cdr (car (cdr c)))))
(defun caddar (c) (car (cdr (cdr (car c)))))
(defun cadddr (c) (car (cdr (cdr (cdr c)))))
(defun cdaaar (c) (cdr (car (car (car c)))))
(defun cdaadr (c) (cdr (car (car (cdr c)))))
(defun cdadar (c) (cdr (car (cdr (car c)))))
(defun cdaddr (c) (cdr (car (cdr (cdr c)))))
(defun cddaar (c) (cdr (cdr (car (car c)))))
(defun cddadr (c) (cdr (cdr (car (cdr c)))))
(defun cdddar (c) (cdr (cdr (cdr (car c)))))
(defun cddddr (c) (cdr (cdr (cdr (cdr c)))))

(defun first (lizt) (car lizt))
(defun second (lizt) (cadr lizt))
(defun third (lizt) (caddr lizt))
(defun fourth (lizt) (cadddr lizt))
(defun fifth (lizt) (car (cddddr lizt)))
(defun sixth (lizt) (cadr (cddddr lizt)))
(defun seventh (lizt) (caddr (cddddr lizt)))
(defun eighth (lizt) (cadddr (cddddr lizt)))

(defun cons? (x)
  (eq? (type x) cons-t))

(defun nil? (x)
  (eq? x nil))

(defun member? (elem lizt)
  (if (nil? lizt)
    false
    (or (eq? (car lizt) elem)
        (member? elem (cdr lizt)))))

(defun length (lizt)
  (%length lizt 0))

(defun %length (lizt acc)
  (if (nil? lizt)
    acc
    (%length (cdr lizt) (1+ acc))))

(defun length-is? (lizt len)
  (cond
    ((< len 0) false)
    ((nil? lizt) (eq? len 0))
    (true (length-is? (cdr lizt) (1- len)))))

(defun each (func lizt)
  (if (not (nil? lizt))
    (progn
      (func (car lizt))
      (each func (cdr lizt)))))

(defun each-cons (func lizt)
  (if (not (nil? lizt))
    (progn
      (func lizt)
      (each func (cdr lizt)))))

(defun map (func lizt)
  (let ((list-head (cons nil nil)))
    (%map list-head func lizt)
    (cdr list-head)))

(defun %map (list-head func lizt)
  (if (not (nil? lizt))
    (let ((next-list (cons (func (car lizt)) nil)))
      (set-cdr list-head next-list)
      (%map (cdr list-head) func (cdr lizt)))))

(defun assoc (kar alist)
  (cond
    ((nil? alist) nil)
    ((eq? (caar alist) kar) (car alist))
    (true (assoc kar (cdr alist)))))

(defun list-eq? (l1 l2)
  (cond ((nil? l1) (nil? l2))
        ((nil? l2) (nil? l1))
        (true (and (eq? (car l1) (car l2))
                   (list-eq? (cdr l1) (cdr l2))))))

(defun append! (l1 l2)
  (%append! l1 l2)
  l1)

(defun %append! (l1 l2)
  (if (nil? (cdr l1))
     (set-cdr l1 l2)
     (%append! (cdr l1) l2)))
