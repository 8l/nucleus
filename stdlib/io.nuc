;;;; This file defines all functions relating to input and output.

(extern rt_write_char 1 -> write-char)
(extern rt_read_char 0 -> read-char)
(extern rt_write_string 1 -> write-string)
(extern rt_write_string_ln 1 -> write-string-ln)
(extern rt_symbol_to_string 1 -> string<-symbol)
(extern rt_string_to_symbol 1 -> symbol<-string)


(defun print (sexp)
  (case (type sexp)
    (fixnum-t (print-fixnum sexp))
    (cons-t (print-cons sexp))
    (nil-t (write-string "nil"))
    (bool-t (write-string (if sexp "true" "false")))
    (symbol-t (write-string (string<-symbol sexp)))
    ;; TODO: this doesn't actually work until we support 'otherwise' or something
    (true
      (panic! "Can't print this type"))))

(defun print-fixnum (x)
  (if (< x 10)
    (write-char (+ x #\0))
    (let* ((ndigits (ceiling (log10 (float<-int x))))
           (multiplier (expt 10 (1- ndigits))))
      (write-char (+ (/ x multiplier) #\0))
      (print-fixnum (- x (* (/ x multiplier) multiplier))))))

(defun print-cons (c)
  (write-string "(")
  (print (car c))
  (%print-tail (cdr c)))

(defun %print-tail (c)
  (cond
    ((nil? c)
     (write-string ")"))
    ((cons? c)
     (write-string " ")
     (print (car c))
     (%print-tail (cdr c)))
    (true
     (write-string " . ")
     (print c)
     (write-string ")"))))


(defvar $unread-char nil)

(defun %read-char ()
  (cond
    ((nil? $unread-char)
     (read-char))
    (true
      (let ((c $unread-char))
        (set $unread-char nil)
        c))))

(defun back-up-char (c)
  (if (nil? $unread-char)
    (set $unread-char c)
    ;; We should only ever need to do this once before reading another char
    (panic! "Tried to back up when there was already an unread char")))

;;; When and only when EOF is reached, read returns a value eq? to this
(defvar $eof (cons nil nil))

(defun read ()
  (let ((c (%read-char)))
    (cond
      ((eq? c #\;)
       (skip-comment)
       (read))
      ((or (eq? c 32) (eq? c 10)) ; ' ' or '\n'
       (read))
      ((eq? c #\")
       (let ((list-head (cons nil nil)))
         (read-string list-head)
         (string<-char-list (cdr list-head))))
      ((<= #\0 c #\9) (read-fixnum (- c #\0)))
      ((eq? c #\()
       (let ((list-head (cons nil nil)))
         (read-list list-head)
         (cdr list-head)))
      ((eof? c) $eof)
      (true
        (let ((list-head (cons c nil)))
          (read-symbol list-head)
          (symbol<-string (string<-char-list list-head)))))))

(defun skip-comment ()
  (let ((c (%read-char)))
    (if (not (eq? c 10)) ; '\n' 
      (skip-comment))))

(defun read-string (list-head)
  (let ((c (%read-char)))
    (cond
      ((eq? c #\") nil)
      (true
        (set-cdr list-head (cons c nil))
        (read-string (cdr list-head))))))

(defun read-fixnum (acc)
  (let ((c (%read-char)))
    (cond
      ((<= #\0 c #\9)
       (read-fixnum (+ (* acc 10) (- c #\0))))
      (true
        (back-up-char c)
        acc))))

(defun read-list (list-head)
  (let ((c (%read-char)))
    (cond
      ((eq? c #\)) nil)
      (true
        (back-up-char c)
        (let ((next (read)))
          (set-cdr list-head (cons next nil))
          (read-list (cdr list-head)))))))

(defun read-symbol (list-head)
  (let ((c (%read-char)))
    (cond
      ((symbol-char? c)
       (set-cdr list-head (cons c nil))
       (read-symbol (cdr list-head)))
      (true
        (back-up-char c)))))

(defun eof? (c)
  (< c 0))

(defun symbol-char? (c)
  (and (not (eof? c))
       (not (member? c (list #\; 32 10 #\" #\( #\))))))
