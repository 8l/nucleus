(defvar $builtin-functions
  (list
    (cons (quote +) builtin+)
    (cons (quote -) builtin-)
    (cons (quote *) builtin*)))
(defvar $special-forms
  (list
    (cons (quote set) special-form-set)
    (cons (quote let) special-form-let)
    (cons (quote let*) special-form-let*)
    (cons (quote progn) special-form-progn)))

(defun get-special-form (name)
  (let ((special-form (assoc name $special-forms)))
    (if (not (nil? special-form))
      (cdr special-form)
      nil)))

(defun get-builtin-function (name)
  (let ((builtin-function (assoc name $builtin-functions)))
    (if (not (nil? builtin-function))
      (cdr builtin-function)
      nil)))

(defun special-form-set (context args)
  (let* ((env (context-env context))
         (name (first args))
         (lvalue (get-lvalue context name))
         (new-value (compile-expr context (second args))))
    (if (null? lvalue)
      (panic! "Undefined variable")
      (LLVMBuildStore $builder new-value lvalue ""))
    new-value))

(defun special-form-progn (context args)
  (compile-progn context args))

(defun special-form-let (context args)
  (let* ((bindings (first args))
         (body (rest args))
         (names (map first bindings))
         (values (map (lambda (e) (compile-expr context e))
                      (map second bindings)))
         (new-context (extend-env context names values)))
    (compile-progn new-context body)))

;; TODO: make into a macro
(defun special-form-let* (context args)
  (compile-expr context
                (if (nil? (first args))
                  (cons (quote progn) (rest args))
                  (list (quote let) (list (caar args))
                        (cons (quote let*) (cons (cdar args) (rest args)))))))

(defun special-form-progn (context args)
  (compile-progn context args))

(defun compile-progn (context forms)
  (let ((e (compile-expr context (car forms))))
    (if (nil? (cdr forms))
      e
      (compile-progn context (cdr forms)))))

(defun get-lvalue (context name)
  (let ((global (LLVMGetNamedGlobal $module (mangle-name name))))
    (if (not (null? global))
      global
      (let ((lexical-binding (assoc name (context-env context))))
        (if (nil? lexical-binding)
          nil
          (cdr lexical-binding))))))

;; We don't bother dealing with the lowtag here, because the lowtag for fixnums
;; is zero, and shifting is a multiplication, which distributes over addition
;; and subtraction - shifting each operand right and then the result left is
;; the same as not shifting at all.
(defun builtin+ (args) (reduce (lambda (a b) (LLVMBuildAdd $builder a b "+")) args))
(defun builtin- (args) (reduce (lambda (a b) (LLVMBuildSub $builder a b "-")) args))
(defun builtin* (args)
  (reduce (lambda (a b)
            ;; Rather than shifting each operand right and the result left, we
            ;; just deal with the extra factor of 2^LOWTAG-BITS by shifting
            ;; the result.
            ;; TODO: If we have type information about the upper bound of the
            ;; operands we can batch these shifts rather than shifting every
            ;; time. The only reason we can't is overflow, which we may be able
            ;; to statically determine to be impossible.
            (LLVMBuildLShr
              $builder
              (LLVMBuildMul $builder a b "*")
              (llvm-val<-int LOWTAG-BITS)
              ""))
          args))
