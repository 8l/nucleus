; TODO: including a directory should look for 'lib' inside it
(include "llvm/lib")

(include "builtins")
(include "types")

(defvar $builder)
(defvar $module)

(defun main ()
  (cond
    ((length-is? $argv 2)
     (set $builder (LLVMCreateBuilder))
     (let* ((input-filename (second $argv))
            (stream (open input-filename))
            (context (LLVMGetGlobalContext))
            (forms (read-all stream)))
       (set $module (LLVMModuleCreateWithNameInContext input-filename context))
       (close stream)
       (each process-form forms)
       ;; TODO: use function composition when that works
       (each (lambda (f) (compile-function (cdr f))) $functions)
       (when (LLVMVerifyModule $module LLVMPrintMessageAction NULL)
          (LLVMDumpModule $module)
          (panic! "ICE: Module failed LLVMVerifyModule. Module has been dumped"))
       (LLVMWriteBitcodeToFile $module "test.bc")
       (exec "llc" (list "test.bc" "-filetype=obj" "-o" "test.o"))
       (exec "gcc" (list "test.o"))
       (exec "rm" (list "test.bc" "test.o"))))
    (true 
      (write-string-ln "Usage: nucc <input filename>"))))

(defun read-all (stream)
  (let ((list-head (cons nil nil)))
    (%read-all list-head stream)
    (cdr list-head)))

(defun %read-all (list-head stream)
  (let ((sexp (read-from-stream stream)))
    (cond
      ((not (eq? sexp EOF))
       (set-cdr list-head (cons sexp nil))
       (%read-all (cdr list-head) stream)))))

(defun process-form (form)
  (case (first form)
    ((quote defun)
     (let* ((name (second form))
            (args (third form))
            (arity (length args))
            (body (cdddr form)))
       (declare-function (second form)
                         NUC-VAL
                         (map (lambda (_) NUC-VAL) (third form)))
       (add-func (make-func name arity args body))))))

(defun declare-function (name ret-type arg-types)
  (LLVMAddFunction
    $module
    (mangle-name name)
    (LLVMFunctionType ret-type arg-types (length arg-types) false)))

;;; TODO: Replace with a struct once they exist
(defun make-func (name arity args body) (list name arity args body))
(defun func-name (func) (first func))
(defun func-arity (func) (second func))
(defun func-args (func) (third func))
(defun func-body (func) (fourth func))

;;; TODO: Replace with a hash table once that exists
(defvar $functions nil)
(defvar $constants nil)
(defvar $env nil)

(defun add-func (f)
  (cond
    ((not (nil? (get-func (func-name f))))
     (format true "Duplicate definition of function '~'" (func-name f))
     (write-string-ln "")
     (panic! "Aborting"))
    (true
      (set $functions (cons (cons (func-name f) f) $functions)))))

(defun get-func (name) (assoc name $functions))

(defun compile-function (func)
  (let ((llvm-func (LLVMGetNamedFunction $module (mangle-name (func-name func)))))
    (assert! (not (nil? llvm-func)) "Function should have been declared")
    (LLVMPositionBuilderAtEnd $builder (LLVMAppendBasicBlock llvm-func "entry"))
    (let* ((body (if (nil? (func-body func)) (list nil) (func-body func)))
           (compiled (each-cons (lambda (c)
                                  (let ((e (compile-expr (car c))))
                                    (if (nil? (cdr c))
                                      (LLVMBuildRet $builder e))))
                                body)))
      (when (LLVMVerifyFunction llvm-func LLVMPrintMessageAction)
        (LLVMDumpValue llvm-func)
        (panic! "ICE: Function failed LLVMVerifyFunction. Function has been dumped"))
      compiled)))

(defun mangle-name (name)
  (if (eq? name (quote main))
    "main"
    (format nil "nuc(~)" name)))

(defun compile-expr (expr)
  (case (type expr)
    ;; TODO: limit on size
    (fixnum-t (llvm-val<-int (<< expr LOWTAG-BITS)))
    #+nil
    (symbol-t (let ((const (cdr (assoc expr *constants*))))
                (if const
                  const
                  (multiple-value-bind (binding bindingp) (lookup-lvalue expr)
                    (if bindingp
                      (llvm:build-load *builder* binding (string expr))
                      (error "Undefined variable '~S'~%" expr))))))
    (cons-t (compile-form expr))
    #+nil
    (string-t (llvm:build-call
              *builder*
              (extern-func "rt_make_string" *nuc-val* *size-t*
                           (llvm:pointer-type (llvm:int-type 8)))
              (list (llvm-val<-int (length expr))
                    (llvm:build-gep
                      *builder*
                      (llvm:build-global-string *builder* expr "string-lit")
                      (make-array (list 2) :initial-element (llvm-val<-int 0))
                      "str-to-ptr"))
              "make-literal-string"))
    (default (println expr)
             (panic! "Don't know how to compile this type of expression"))))

(defun compile-form (form)
  (let ((special-form (get-special-form (car form))))
    (if (not (nil? special-form))
      (special-form  (cdr form))
      (let ((builtin-function (get-builtin-function (car form))))
        (cond ((not (nil? builtin-function))
               (builtin-function (map compile-expr (cdr form))))
              (true (panic! "Undefined function")))))))

(defun llvm-val<-int (x)
  (LLVMConstInt NUC-VAL x false))
