;;; TODO: Replace with a struct once they exist
(defun make-func (name arity args body llvm-func)
  (list name arity args body llvm-func))
(defun func-name (func) (first func))
(defun func-arity (func) (second func))
(defun func-args (func) (third func))
(defun func-body (func) (fourth func))
(defun func-llvm-func (func) (fifth func))

;;; TODO: Replace with a hash table once that exists
;;; TODO: These should go in the context, along with $module and $builder
(defvar $functions nil)

;;; TODO: Replace with a struct once they exist
(defun make-context (env) (list env))
(defun context-env (context) (first context))
(defun context-set-env (context new-env) (set-car context new-env))

(defun add-func (f)
  (cond
    ((not (nil? (get-func (func-name f))))
     (format true "Duplicate definition of function '~'" (func-name f))
     (write-string-ln "")
     (panic! "Aborting"))
    (true
      (set $functions (cons (cons (func-name f) f) $functions)))))

(defun get-func (name) (assoc-cdr name $functions))

(defvar $initialisers nil)

(defun add-initialiser (var init)
  (set $initialisers (cons (cons var init) $initialisers)))

(defun mangle-name (name)
  (format nil "nuc(~)" name))

(defun extend-env (context vars values)
  (let ((env (context-env context)))
    (each (lambda (name-and-value)
            (let ((var (car name-and-value))
                  (value (cdr name-and-value))
                  (var-on-stack (LLVMBuildAlloca $builder NUC-VAL "")))
              (LLVMBuildStore $builder value var-on-stack)
              (set env (cons (cons var var-on-stack) env))))
          (zip vars values))
    (make-context env)))

(defun declare-function (name ret-type arg-types)
  (LLVMAddFunction
    $module
    (mangle-name name)
    (LLVMFunctionType ret-type arg-types (length arg-types) false)))

(defun get-value (context name)
  (let ((lvalue (get-lvalue context name)))
    (if (nil? lvalue)
      (get-constant name)
      (LLVMBuildLoad $builder lvalue (string<-symbol name)))))

(defun get-lvalue (context name)
  (let ((global (LLVMGetNamedGlobal $module (mangle-name name))))
    (if (not (null? global))
      global
      (let ((lexical-binding (assoc name (context-env context))))
        (if (nil? lexical-binding)
          nil
          (cdr lexical-binding))))))

(defun remove-lowtag (nuc-val)
  (LLVMBuildAnd
    $builder
    nuc-val
    ;; TODO: replace with (~ (1- (<< 1 LOWTAG-BITS)))
    (llvm-val<-int 18446744073709551608)
    "remove-lowtag"))

(defun llvm-val<-int (x)
  (LLVMConstInt NUC-VAL x false))

(defun llvm-val<-int8 (x)
  (LLVMConstInt (LLVMIntType 8) x false))

(defun llvm-val<-int32 (x)
  (LLVMConstInt (LLVMIntType 32) x false))

(defun cons<-nuc-val (nuc-val)
  ; TODO: type checking
  (LLVMBuildIntToPtr
    $builder
    (remove-lowtag nuc-val)
    CONS-CELL-PTR
    ""))

(defun compile-progn (context forms)
  (let ((e (compile-expr context (car forms))))
    (if (nil? (cdr forms))
      e
      (compile-progn context (cdr forms)))))

(defun compile-lambda (context name args body captured-vars)
  (let* ((params (repeat (length args) NUC-VAL))
         ;; We only take the lambda struct as our first argument if we have
         ;; any captured bindings. This allows us to easily deal with passing
         ;; around static functions in lambdas.
         ;; TODO: We could optimize further by not allocating a new closure if
         ;; we don't capture any bindings, and instead just creating a static
         ;; closure once at compile-time and returning it every time.
         (func (declare-function (mangle-name name)
                                 NUC-VAL
                                 (if (nil? captured-vars)
                                   params
                                   (cons (LLVMPointerType CLOSURE) params)))))
    (when (nil? body)
      (set body (list (quote nil))))
    ;; TODO: set LLVM param names
    (LLVMPositionBuilderAtEnd $builder (LLVMAppendBasicBlock func "entry"))
    (let* ((params (llvm-params func))
           (new-context
             (extend-env
               context
               (append
                 captured-vars
                 args)
               (append!
                 (map
                   (lambda (i-name)
                     (let ((i (car i-name))
                           (name (cdr i-name)))
                       (LLVMBuildLoad
                         $builder
                         (LLVMBuildGEP
                           $builder
                           (LLVMBuildGEP $builder (first params)
                                         (map llvm-val<-int32 (list 0 2))
                                         2
                                         "")
                           (map llvm-val<-int (list 0 i))
                           2
                           "get-var-from-closure")
                         "")))
                   (zip captured-vars (range (length captured-vars))))
                 (map (lambda (arg-name-llvm-param)
                        (let* ((arg-name (car arg-name-llvm-param))
                               (llvm-param (cdr arg-name-llvm-param))
                               (arg-on-stack
                                 (LLVMBuildAlloca $builder NUC-VAL
                                                  (string<-symbol arg-name))))
                          (LLVMBuildStore $builder llvm-param arg-on-stack)
                          arg-on-stack))
                      (zip args
                           (if (nil? captured-vars)
                             (llvm-params func)
                             (cdr (llvm-params func)))))))))
      (LLVMBuildRet $builder (compile-progn context body)))
    (when (LLVMVerifyFunction func LLVMPrintMessageAction)
      (LLVMDumpValue func)
      (panic! (format nil "ICE compiling lambda ~ (failed LLVMVerifyFunction). Function has been dumped" name)))
    func))

(defun make-lambda (func arity captures)
  (let* ((ary-type (LLVMArrayType (LLVMPointerType NUC-VAL) (length captures)))
         (captures-array
           (if (nil? captures)
             (LLVMConstNull ary-type)
             (LLVMBuildAlloca $builder ary-type "make-captures-array"))))
    (enumerate (lambda (i capture)
                 ;; TODO: insert-value?
                 (LLVMBuildStore
                   $builder
                   (cdr capture)
                   (LLVMBuildGEP $builder captures-array
                                 (map llvm-val<-int (list 0 i))
                                 2 "array-elt")))
               captures)
    (LLVMBuildCall
      $builder
      (runtime-func "rt_make_lambda" NUC-VAL
                    (list UINTPTR (LLVMIntType 8) (LLVMIntType 32) UINTPTR))
      (list (LLVMBuildPtrToInt $builder func UINTPTR "func-pointer-to-int")
            (llvm-val<-int8 arity)
            (llvm-val<-int32 (length captures))
            (if (nil? captures)
              (llvm-val<-int 0)
              (LLVMBuildPtrToInt $builder captures-array UINTPTR "array-to-int")))
      4
      "make-lambda")))

(defun runtime-func (name return-type arg-types)
  (let ((func (LLVMGetNamedFunction $module name)))
    (if (not (null? func))
      func
      (LLVMAddFunction
        $module name
        (LLVMFunctionType return-type arg-types (length arg-types) false)))))

(defun global-string (str)
  (LLVMBuildGEP
    $builder
    (LLVMBuildGlobalString $builder str "")
    (list (llvm-val<-int 0) (llvm-val<-int 0))
    2
    "str-to-ptr"))
