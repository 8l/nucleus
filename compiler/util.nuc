;;; TODO: Replace with a struct once they exist
(defun make-func (name arity args body llvm-func)
  (list name arity args body llvm-func))
(defun func-name (func) (first func))
(defun func-arity (func) (second func))
(defun func-args (func) (third func))
(defun func-body (func) (fourth func))
(defun func-llvm-func (func) (fifth func))

;;; TODO: Replace with a hash table once that exists
;;; TODO: These should go in the context, along with $module and $builder
(defvar $functions nil)

;;; TODO: Replace with a struct once they exist
(defun make-context (env) (list env))
(defun context-env (context) (first context))
(defun context-set-env (context new-env) (set-car context new-env))

(defun add-func (f)
  (cond
    ((not (nil? (get-func (func-name f))))
     (panic! (format nil "Duplicate definition of function '~'" (func-name f))))
    (true
      (set $functions (cons (cons (func-name f) f) $functions)))))

(defun get-func (name) (assoc-cdr name $functions))

(defvar $initialisers nil)

(defun add-initialiser (var init)
  (set $initialisers (cons (cons var init) $initialisers)))

(defun mangle-name (name)
  (format nil "nuc(~)" name))

(defun extend-env-with-values (context names values)
  (let ((env (context-env context)))
    (each (lambda (name-and-value)
            (let* ((name (car name-and-value))
                   (value (cdr name-and-value))
                   (var-on-stack (LLVMBuildAlloca $builder NUC-VAL
                                                  (string<-symbol name))))
              (LLVMBuildStore $builder value var-on-stack)
              (set env (cons (cons name var-on-stack) env))))
          (zip names values))
    (make-context env)))

(defun extend-env-with-pointers (context names ptrs)
  (make-context (append (zip names ptrs) (context-env context))))

(defun declare-function (name ret-type arg-types)
  (LLVMAddFunction
    $module
    name
    (LLVMFunctionType ret-type arg-types (length arg-types) false)))

(defun get-value (context name)
  (let ((lvalue (get-lvalue context name)))
    (if (not (nil? lvalue))
      (LLVMBuildLoad $builder lvalue (string<-symbol name))
      (let ((const (get-constant name)))
        (if (not (nil? const))
          const
          (let ((func (get-func name)))
            (if (not (nil? func))
              (make-lambda (func-llvm-func func)
                           (LLVMCountParams (func-llvm-func func))
                           nil)
              nil)))))))

(defun get-lvalue (context name)
  (let ((global (LLVMGetNamedGlobal $module (mangle-name name))))
    (if (not (null? global))
      global
      (assoc-cdr name (context-env context)))))

(defun remove-lowtag (nuc-val)
  (LLVMBuildAnd $builder nuc-val
                ;; TODO: replace with (~ (1- (<< 1 LOWTAG-BITS)))
                (llvm-val<-int 18446744073709551608) "remove-lowtag"))

(defun add-lowtag (nuc-val tag)
  (LLVMBuildOr $builder
               (LLVMBuildPtrToInt $builder nuc-val NUC-VAL "ptr-to-int")
               (llvm-val<-int tag) "add-lowtag"))

;; TODO: rename these
(defun llvm-val<-int (x) (LLVMConstInt NUC-VAL x false))
(defun llvm-val<-int8 (x) (LLVMConstInt (LLVMIntType 8) x false))
(defun llvm-val<-int32 (x) (LLVMConstInt (LLVMIntType 32) x false))
(defun nuc-val<-int (int)
  (LLVMBuildShl $builder int (llvm-val<-int LOWTAG-BITS) "nuc-val<-int"))
(defun int<-nuc-val (nuc-val)
  ; TODO: type checking
  (LLVMBuildLShr $builder nuc-val (llvm-val<-int LOWTAG-BITS) "int<-nuc-val"))

(defun cons<-nuc-val (nuc-val)
  ; TODO: type checking
  (LLVMBuildIntToPtr $builder (remove-lowtag nuc-val) CONS-CELL-PTR ""))

(defun gc-alloc (size)
  (LLVMBuildCall
    $builder (runtime-func "gc_alloc" (LLVMPointerType NUC-VAL 0) SIZE-T)
    (list (llvm-val<-int size)) 1 "gc_alloc"))

(defun compile-progn (context forms)
  (%compile-progn context (if (nil? forms) (list (quote nil)) forms)))

(defun %compile-progn (context forms)
  (let ((e (compile-expr context (car forms))))
    (if (nil? (cdr forms))
      e
      (%compile-progn context (cdr forms)))))

(defun compile-lambda (context name args body captured-vars)
  (let* ((params (repeat (length args) NUC-VAL))
         ;; We only take the lambda struct as our first argument if we have
         ;; any captured bindings. This allows us to easily deal with passing
         ;; around static functions in lambdas.
         ;; TODO: We could optimize further by not allocating a new closure if
         ;; we don't capture any bindings, and instead just creating a static
         ;; closure once at compile-time and returning it every time.
         (func (declare-function (mangle-name name) NUC-VAL
                                 (if (nil? captured-vars)
                                   params
                                   (cons (LLVMPointerType CLOSURE 0) params)))))
    ;; TODO: set LLVM param names
    (LLVMPositionBuilderAtEnd $builder (LLVMAppendBasicBlock func "entry"))
    (let* ((params (llvm-params func))
           (new-context
             (extend-env-with-values
               (extend-env-with-pointers
                 context
                 captured-vars
                 (map (lambda (i-name)
                        (let ((i (car i-name))
                              (name (cdr i-name)))
                          (LLVMBuildLoad
                            $builder
                            (LLVMBuildGEP
                              $builder
                              (LLVMBuildGEP $builder (first params)
                                            (map llvm-val<-int32 (list 0 2))
                                            2
                                            "")
                              (map llvm-val<-int (list 0 i))
                              2
                              "get-var-from-closure")
                            "")))
                      (zip (range (length captured-vars)) captured-vars)))
               args
               (if (nil? captured-vars)
                 (llvm-params func)
                 (cdr (llvm-params func))))))
      (LLVMBuildRet $builder (compile-progn new-context body)))
    (when (LLVMVerifyFunction func LLVMPrintMessageAction)
      (LLVMDumpValue func)
      (panic! (format nil "ICE compiling lambda ~ (failed LLVMVerifyFunction). Function has been dumped" name)))
    func))

(defun call-closure (context nuc-val args)
  (let* ((closure (LLVMBuildIntToPtr
                    $builder (remove-lowtag nuc-val) (LLVMPointerType CLOSURE 0) ""))
         (func-pointer
           (LLVMBuildLoad
             $builder
             ;; TODO: BuildStructGEP?
             (LLVMBuildGEP
               $builder
               closure
               (map llvm-val<-int32 (list 0 0))
               2
               "")
             "load-func-pointer-from-struct"))
         (current-func (get-current-func $builder))
         (args (map (lambda (e) (compile-expr context e)) args))
         (args-len (length args))
         (captures
           (LLVMBuildGEP
             $builder
             (LLVMBuildGEP $builder closure (map llvm-val<-int32 (list 0 2)) 2 "")
             (map llvm-val<-int32 (list 0 0))
             2
             ""))
         (first-capture (LLVMBuildLoad $builder captures "")))
    ;; TODO: This is a case where a "declare in current scope" special form
    ;; could be really useful - a bunch of assignments interspersed with
    ;; side-effecting calls
    (let ((then-block (LLVMAppendBasicBlock current-func "doesn't-take-closure"))
          (else-block (LLVMAppendBasicBlock current-func "takes-closure"))
          (after-block (LLVMAppendBasicBlock current-func "after-call")))
      (LLVMBuildCondBr
        $builder
        (LLVMBuildICmp $builder LLVMIntEQ
                       (LLVMBuildPtrToInt $builder first-capture UINTPTR "")
                       (llvm-val<-int 0) "")
        then-block
        else-block)
      (LLVMPositionBuilderAtEnd $builder then-block)
      (let ((then-result (LLVMBuildCall
                           $builder
                           (LLVMBuildIntToPtr
                             $builder
                             func-pointer
                             (LLVMPointerType
                               (LLVMFunctionType
                                 NUC-VAL
                                 (repeat args-len NUC-VAL)
                                 args-len
                                 false)
                               0)
                             "cast-to-correct-function-type")
                           args
                           args-len
                           "call-closure")))
        (LLVMBuildBr $builder after-block)
        (LLVMPositionBuilderAtEnd $builder else-block)
        (let ((else-result
                (LLVMBuildCall
                  $builder
                  (LLVMBuildIntToPtr
                    $builder
                    func-pointer
                    (LLVMPointerType
                      (LLVMFunctionType
                        NUC-VAL
                        (cons (LLVMPointerType CLOSURE 0)
                              (repeat args-len NUC-VAL))
                        (1+ args-len)
                        false)
                      0)
                    "cast-to-correct-function-type")
                  (cons closure args)
                  (1+ args-len)
                  "call-closure")))
          (LLVMBuildBr $builder after-block)
          (LLVMPositionBuilderAtEnd $builder after-block)
          (llvm-phi $builder NUC-VAL (list (cons then-result then-block)
                                           (cons else-result else-block))))))))

(defun make-lambda (func arity captures)
  (let* ((ary-type (LLVMArrayType (LLVMPointerType NUC-VAL 0) (length captures)))
         (captures-array
           (if (nil? captures)
             (LLVMConstNull ary-type)
             (LLVMBuildAlloca $builder ary-type "make-captures-array"))))
    (enumerate (lambda (i capture)
                 ;; TODO: insert-value?
                 (LLVMBuildStore
                   $builder
                   (cdr capture)
                   (LLVMBuildGEP $builder captures-array
                                 (map llvm-val<-int (list 0 i))
                                 2 "array-elt")))
               captures)
    (LLVMBuildCall
      $builder
      (runtime-func "rt_make_lambda" NUC-VAL
                    (list UINTPTR (LLVMIntType 8) (LLVMIntType 32) UINTPTR))
      (list (LLVMBuildPtrToInt $builder func UINTPTR "func-pointer-to-int")
            (llvm-val<-int8 arity)
            (llvm-val<-int32 (length captures))
            (if (nil? captures)
              (llvm-val<-int 0)
              (LLVMBuildPtrToInt $builder captures-array UINTPTR "array-to-int")))
      4
      "make-lambda")))

(defun runtime-func (name return-type arg-types)
  (let ((func (LLVMGetNamedFunction $module name)))
    (if (not (null? func))
      func
      (LLVMAddFunction
        $module name
        (LLVMFunctionType return-type arg-types (length arg-types) false)))))

(defun global-string (str)
  (LLVMBuildGEP
    $builder
    (LLVMBuildGlobalString $builder str "")
    (list (llvm-val<-int 0) (llvm-val<-int 0))
    2
    "str-to-ptr"))

(defun find-captured-vars (context body)
  (unique (%find-captured-vars context body nil)))

(defun %find-captured-vars (context sexpr to-ignore)
  (cond
    ((atom? sexpr)
     (if (member? sexpr to-ignore)
       nil
       (let ((binding (get-lvalue context sexpr)))
         (if (nil? binding) nil (list (cons sexpr binding))))))
    ((or (eq? (car sexpr) (quote let)) (eq? (car sexpr) (quote let*)))
     ;; let/let* can shadow variables, producing spurious captures
     (%find-captured-vars context
                          (cddr sexpr)
                          (append! (map car (second sexpr)) to-ignore)))
    (true (mappend (lambda (e) (%find-captured-vars context e to-ignore)) sexpr))))
 
(defun llvm-type<-type-spec (type-spec)
  (case type-spec
    ((quote *) UINTPTR)
    ((quote string) (LLVMPointerType (LLVMIntType 8) 0))
    ((quote void) (LLVMVoidType))
    ((quote int) INT) ((quote uint) INT) ((quote bool) INT)
    ((quote long) LONG)
    ((quote long-long) LONG-LONG)
    ((quote array) (LLVMPointerType UINTPTR 0))
    (default (panic! (format nil "Unsupported type-spec '~'" type-spec)))))

(defun c-val<-nuc-val (type-spec val)
  (cond
    ((eq? type-spec (quote *))
     (LLVMBuildIntToPtr
       $builder
       (LLVMBuildLoad
         $builder
         (LLVMBuildIntToPtr
           $builder (remove-lowtag val) (LLVMPointerType NUC-VAL 0) "")
         "")
       UINTPTR
       ""))
    ((eq? type-spec (quote string))
     (LLVMBuildCall
       $builder
       (runtime-func "rt_nuc_str_to_c_str" (LLVMPointerType (LLVMIntType 8) 0) (list NUC-VAL))
       (list val) 1 "c-val<-nuc-val"))
    ((member? type-spec (list (quote int) (quote uint) (quote long) (quote long-long)))
     (LLVMBuildIntCast
       $builder
       (int<-nuc-val val)
       (llvm-type<-type-spec type)
       "downcast-nuc-val-to-int"))
    ((eq? type-spec (quote bool))
      (LLVMBuildIntCast
        $builder
        (LLVMBuildICmp $builder LLVMIntEQ val LLVM-TRUE "int<-bool")
        (llvm-type<-type-spec (quote int))
        ""))
    ((eq? type-spec (quote array))
     (LLVMBuildCall
       $builder
       (runtime-func "rt_list_to_array" (llvm-type<-type-spec type) (list NUC-VAL))
       (list val)
       1
       "array<-list"))
    (true (panic! (format nil "Unsupported type-spec '~'" type-spec)))))

(defun nuc-val<-c-val (type-spec val)
  (cond
    ((eq? type-spec (quote *))
      (add-lowtag
        (let ((box (gc-alloc PTR-BYTES)))
          (LLVMBuildStore $builder (LLVMBuildPtrToInt $builder val NUC-VAL "") box)
          box)
        6))
    ((eq? type-spec (quote void)) LLVM-NIL)
    ((member? type-spec
              (list (quote int) (quote uint) (quote long) (quote long-long)))
     (nuc-val<-int
       (LLVMBuildIntCast $builder val NUC-VAL "cast-int-to-nuc-val")))
    ((eq? type-spec (quote bool))
     (LLVMBuildSelect $builder
                      (LLVMBuildICmp $builder LLVMIntEQ val (llvm-val<-int32 0) "")
                      LLVM-TRUE LLVM-FALSE ""))))
