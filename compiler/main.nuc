; TODO: including a directory should look for 'lib' inside it
(include "llvm/lib")

(include "builtins")
(include "types")

(defvar $builder)
(defvar $module)

(defun main ()
  (cond
    ((not (length-is? $argv 1))
     (set $builder (LLVMCreateBuilder))
     (let ((non-flag-args nil)
           (output-llvm-ir false))
       (each (lambda (arg)
               (if (string-eq? arg "-ir")
                 (set output-llvm-ir true)
                 (set non-flag-args (cons arg non-flag-args))))
             $argv)
       (set non-flag-args (reverse non-flag-args))
       (let* ((input-filename (second non-flag-args))
              (output-filename (if (length-is? non-flag-args 2)
                                 "a.out"
                                 (third non-flag-args)))
              (stream (open input-filename))
              (llvm-context (LLVMGetGlobalContext))
              (context (make-context nil))
              (forms (read-all stream)))
         (set $module (LLVMModuleCreateWithNameInContext
                        input-filename llvm-context))
         (close stream)
         (set forms (cons (quote (defvar $status-code)) forms))
         (each process-form forms)
         (each (lambda (f) (compile-function context (cdr f))) $functions)
         (let ((entry-point (LLVMGetNamedFunction
                              $module (mangle-name (quote main))))
               (main-func (LLVMAddFunction $module "main"
                                           (LLVMFunctionType INT nil 0 false))))
           (when (null? entry-point)
             (panic! "No main function defined."))
           (LLVMPositionBuilderAtEnd $builder
                                     (LLVMAppendBasicBlock main-func "entry"))
           ;; TODO: static initialisation here
           (LLVMBuildCall $builder entry-point nil 0 "")
           (LLVMBuildRet
             $builder
             (LLVMBuildIntCast
               $builder
               (LLVMBuildLShr
                 $builder
                 (LLVMBuildLoad
                   $builder (get-lvalue context (quote $status-code)) "")
                 (llvm-val<-int LOWTAG-BITS)
                 "")
               INT
               "truncate-main-result")))
         (when (LLVMVerifyModule $module LLVMPrintMessageAction NULL)
           (LLVMDumpModule $module)
           (panic! "ICE: Module failed LLVMVerifyModule. Module has been dumped"))
         ;; TODO: not portable
         (let ((tmp-bc-file (format nil "/tmp/~.bc" (random)))
               (tmp-o-file (format nil "/tmp/~.o" (random))))
           (LLVMWriteBitcodeToFile $module tmp-bc-file)
           (cond
             (output-llvm-ir
               (let ((llvm-dis-success
                       (zero? (exec "llvm-dis"
                                    (list tmp-bc-file "-o" output-filename)))))
                 (exec "rm" (list tmp-bc-file))
                 (unless llvm-dis-success
                   (panic! "llvm-dis failed"))))
             (true (unless (zero? (exec "llc" (list tmp-bc-file "-filetype=obj"
                                                    "-o" tmp-o-file)))
                     (exec "rm" (list tmp-bc-file))
                     (panic! "llc failed"))
                (unless (zero? (exec "gcc" (list tmp-o-file "-o" output-filename)))
                  (exec "rm" (list tmp-bc-file tmp-o-file))
                  (panic! "gcc failed"))
                (exec "rm" (list tmp-bc-file tmp-o-file))))))))
    (true 
      (write-string-ln "Usage: nucc <input filename>"))))

(defun read-all (stream)
  (let ((list-head (cons nil nil)))
    (%read-all list-head stream)
    (cdr list-head)))

(defun %read-all (list-head stream)
  (let ((sexp (read-from-stream stream)))
    (cond
      ((not (eq? sexp EOF))
       (set-cdr list-head (cons sexp nil))
       (%read-all (cdr list-head) stream)))))

(defun process-form (form)
  (case (first form)
    ((quote defun)
     (let* ((name (second form))
            (args (third form))
            (arity (length args))
            (body (cdddr form))
            (llvm-func
              (declare-function
                (second form) NUC-VAL (map (lambda (_) NUC-VAL) (third form)))))
       (add-func (make-func name arity args body llvm-func))))
    ((quote defvar)
     (let ((name (second form)))
       (LLVMSetInitializer (LLVMAddGlobal $module NUC-VAL (mangle-name name))
                           (llvm-val<-int 0))))))

(defun declare-function (name ret-type arg-types)
  (LLVMAddFunction
    $module
    (mangle-name name)
    (LLVMFunctionType ret-type arg-types (length arg-types) false)))

;;; TODO: Replace with a struct once they exist
(defun make-func (name arity args body llvm-func)
  (list name arity args body llvm-func))
(defun func-name (func) (first func))
(defun func-arity (func) (second func))
(defun func-args (func) (third func))
(defun func-body (func) (fourth func))
(defun func-llvm-func (func) (fifth func))

;;; TODO: Replace with a hash table once that exists
;;; TODO: These should go in the context, along with $module and $builder
(defvar $functions nil)
(defvar $constants nil)

;;; TODO: Replace with a struct once they exist
(defun make-context (env) (list env))
(defun context-env (context) (first context))
(defun context-set-env (context new-env) (set-car context new-env))

(defun add-func (f)
  (cond
    ((not (nil? (get-func (func-name f))))
     (format true "Duplicate definition of function '~'" (func-name f))
     (write-string-ln "")
     (panic! "Aborting"))
    (true
      (set $functions (cons (cons (func-name f) f) $functions)))))

(defun get-func (name)
  (let ((f (assoc name $functions)))
    (if (nil? f) nil (cdr f))))

(defun llvm-params (func)
  (let ((first-param (LLVMGetFirstParam func)))
    (if (null? first-param)
      nil
      (let ((list-head (cons first-param nil)))
        (%llvm-params func list-head)
        list-head))))

(defun %llvm-params (func list-head)
  (let ((param (LLVMGetNextParam (car list-head))))
    (unless (null? param)
      (set-cdr list-head (cons param nil))
      (%llvm-params func (cdr list-head)))))

(defun compile-function (context func)
  (let* ((args (func-args func))
         (env (context-env context))
         (llvm-func (func-llvm-func func))
         (params (llvm-params llvm-func)))
    (assert! (not (null? llvm-func)) "Function should have been declared")
    (LLVMPositionBuilderAtEnd $builder (LLVMAppendBasicBlock llvm-func "entry"))
    ;; TODO: set LLVM param names
    (set context (extend-env context args params))
    (let* ((body (if (nil? (func-body func)) (list nil) (func-body func)))
           (compiled (LLVMBuildRet $builder (compile-progn context body))))
      (when (LLVMVerifyFunction llvm-func LLVMPrintMessageAction)
        (LLVMDumpValue llvm-func)
        (panic! "ICE: Function failed LLVMVerifyFunction. Function has been dumped"))
      compiled)))

(defun extend-env (context vars values)
  (let ((env (context-env context)))
    (each (lambda (name-and-value)
            (let ((var (car name-and-value))
                  (value (cdr name-and-value))
                  (var-on-stack (LLVMBuildAlloca $builder NUC-VAL "")))
              (LLVMBuildStore $builder value var-on-stack "")
              (set env (cons (cons var var-on-stack) env))))
          (zip vars values))
    (make-context env)))

(defun mangle-name (name)
  (format nil "nuc(~)" name))

(defun compile-expr (context expr)
  (case (type expr)
    ;; TODO: limit on size
    (fixnum-t (llvm-val<-int (<< expr LOWTAG-BITS)))
    (symbol-t
      ;; TODO: constants
      (let ((binding (get-lvalue context expr)))
        (if (nil? binding)
          (panic! (format nil "Undefined variable '~'" expr))
          (LLVMBuildLoad $builder binding (string<-symbol expr)))))
    (cons-t (compile-form context expr))
    #+nil
    (string-t (llvm:build-call
              *builder*
              (extern-func "rt_make_string" *nuc-val* *size-t*
                           (llvm:pointer-type (llvm:int-type 8)))
              (list (llvm-val<-int (length expr))
                    (llvm:build-gep
                      *builder*
                      (llvm:build-global-string *builder* expr "string-lit")
                      (make-array (list 2) :initial-element (llvm-val<-int 0))
                      "str-to-ptr"))
              "make-literal-string"))
    (default (panic!
               (format nil
                       "Don't know how to compile this type of expression: ~"
                       expr)))))

(defun compile-form (context form)
  (let* ((name (car form))
         (args (cdr form))
         (special-form (get-special-form name)))
    (if (not (nil? special-form))
      (special-form context args)
      (let ((builtin-function (get-builtin-function name)))
        (if (not (nil? builtin-function))
          (builtin-function (map (lambda (arg) (compile-expr context arg)) args))
          (let ((func (get-func name)))
            (if (nil? func)
              (panic! (format nil "Undefined function '~'" name))
              (LLVMBuildCall
                $builder
                (func-llvm-func func)
                (map compile-expr args)
                (length args)
                ""))))))))

(defun llvm-val<-int (x)
  (LLVMConstInt NUC-VAL x false))
