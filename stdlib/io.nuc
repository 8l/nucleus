;;;; This file defines all functions relating to input and output.

(extern rt_write_char_to_stream 2 -> write-char-to-stream)
(extern rt_read_char_from_stream 1 -> read-char-from-stream)
(extern rt_write_string_to_stream 2 -> write-string-to-stream)
(extern rt_write_string_ln_to_stream 2 -> write-string-ln-to-stream)
(extern rt_write_addr_to_stream 2 -> %write-addr-to-stream)
(extern rt_symbol_to_string 1 -> string<-symbol)
(extern rt_string_to_symbol 1 -> symbol<-string)
(extern rt_make_string_stream 1 -> make-string-stream)
(extern rt_string_stream_to_string 1 -> string<-string-stream)

(defun read-char ()
  (read-char-from-stream $stdin))

(defun write-char (c)
  (write-char-to-stream $stdout c))

(defun write-string (str)
  (write-string-to-stream $stdout str))

(defun write-string-ln (str)
  (write-string-ln-to-stream $stdout str))

(defun print (sexp)
  (print-to-stream $stdout sexp))

(defun println (sexp)
  (print sexp)
  (write-string-ln ""))

(defun plr (sexp)
  (println sexp)
  sexp)

(defun print-to-stream (stream sexp)
  (case (type sexp)
    (fixnum-t (print-fixnum stream sexp))
    (cons-t (print-cons stream sexp))
    (symbol-t (write-string-to-stream stream (string<-symbol sexp)))
    (string-t
      (write-char-to-stream stream #\")
      (write-string-to-stream stream sexp)
      (write-char-to-stream stream #\"))
    (nil-t (write-string-to-stream stream "nil"))
    (bool-t (write-string-to-stream stream (if sexp "true" "false")))
    (foreign-t (%write-addr-to-stream stream sexp))
    (default
      (panic! "Can't print this type"))))

(defun print-fixnum (stream x)
  (if (< x 10)
    (write-char-to-stream stream (+ x #\0))
    (let* ((ndigits (ceiling (log10 (float<-int x))))
           (multiplier (expt 10 (1- ndigits))))
      (write-char-to-stream stream (+ (/ x multiplier) #\0))
      (print-fixnum stream (- x (* (/ x multiplier) multiplier))))))

(defun print-cons (stream c)
  (write-string-to-stream stream "(")
  (print-to-stream stream (car c))
  (%print-tail stream (cdr c)))

(defun %print-tail (stream c)
  (cond
    ((nil? c)
     (write-string-to-stream stream ")"))
    ((cons? c)
     (write-string-to-stream stream " ")
     (print-to-stream stream (car c))
     (%print-tail stream (cdr c)))
    (true
     (write-string-to-stream stream " . ")
     (print-to-stream stream c)
     (write-string-to-stream stream ")"))))


(defvar $unread-char nil)

(defun %read-char (stream)
  (cond
    ((nil? $unread-char)
     (read-char-from-stream stream))
    (true
      (let ((c $unread-char))
        (set $unread-char nil)
        c))))

(defun back-up-char (c)
  (if (nil? $unread-char)
    (set $unread-char c)
    ;; We should only ever need to do this once before reading another char
    (panic! "Tried to back up when there was already an unread char")))

;;; When and only when EOF is reached, read returns a value eq? to this
(defvar EOF (cons nil nil))

(defun read ()
  (read-from-stream $stdin))

(defun read-from-stream (stream)
  (let ((c (%read-char stream)))
    (cond
      ((eq? c #\;)
       (skip-comment stream)
       (read-from-stream stream))
      ((or (eq? c 32) (eq? c 10)) ; ' ' or '\n'
       (read-from-stream stream))
      ((eq? c #\")
       (let ((list-head (cons nil nil)))
         (read-string stream list-head)
         (string<-char-list (cdr list-head))))
      ((<= #\0 c #\9) (read-fixnum stream (- c #\0)))
      ((eq? c #\()
       (let ((list-head (cons nil nil)))
         (read-list stream list-head)
         (cdr list-head)))
      ((eof? c) EOF)
      (true
        (let ((list-head (cons c nil)))
          (read-symbol stream list-head)
          (symbol<-string (string<-char-list list-head)))))))

(defun skip-comment (stream)
  (let ((c (%read-char stream)))
    (if (not (eq? c 10)) ; '\n' 
      (skip-comment stream))))

(defun read-string (stream list-head)
  (let ((c (%read-char stream)))
    (cond
      ((eq? c #\") nil)
      (true
        (set-cdr list-head (cons c nil))
        (read-string stream (cdr list-head))))))

(defun read-fixnum (stream acc)
  (let ((c (%read-char stream)))
    (cond
      ((<= #\0 c #\9)
       (read-fixnum stream (+ (* acc 10) (- c #\0))))
      (true
        (back-up-char c)
        acc))))

(defun read-list (stream list-head)
  (let ((c (%read-char stream)))
    (cond
      ((eq? c #\)) nil)
      (true
        (back-up-char c)
        (let ((next (read-from-stream stream)))
          (set-cdr list-head (cons next nil))
          (read-list stream (cdr list-head)))))))

(defun read-symbol (stream list-head)
  (let ((c (%read-char stream)))
    (cond
      ((symbol-char? c)
       (set-cdr list-head (cons c nil))
       (read-symbol stream (cdr list-head)))
      (true
        (back-up-char c)))))

(defun eof? (c)
  (< c 0))

(defun symbol-char? (c)
  (and (not (eof? c))
       (not (member? c (list #\; 32 10 #\" #\( #\))))))

;;; TODO: Once we have varargs we should define this as a variable arity
;;; function rather than having a compiler builtin.
;;; TODO: Also once we have varargs we can easily create a wrapper that appends
;;; a newline rather than doing it by default
(defun %format (stream-spec format-str arg-list)
  (let ((stream (case stream-spec
                  (true $stdout)
                  (nil (make-string-stream ""))
                  (default stream-spec)))
        (len (length format-str)))
    (upto len
          (lambda (i)
            (let ((c (char-at format-str i)))
              (cond
                ((eq? c #\~)
                 (assert! (not (nil? arg-list)) "Not enough args to format.")
                 (print-to-stream stream (car arg-list))
                 (set arg-list (cdr arg-list)))
                (true (write-char-to-stream stream c))))))
    (write-char-to-stream stream 10)
    (if (eq? stream-spec nil)
      (string<-string-stream stream)
      nil)))
